<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>黄默悦的博客</title>
    <link>http://eledata.github.io</link>
    <description>My personal blog</description>
    
      <item>
        <title>Advance SQL 系列之系统管理</title>
        <link>http://eledata.github.io/2015/10/14/Oracle-SQL.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2015/10/14/Oracle-SQL.html</guid>
        <pubDate>Wed, 14 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2&gt;表空间管理&lt;/h2&gt;

&lt;h3&gt;增加表空间&lt;/h3&gt;

&lt;p&gt;在数据增长量不大的情况下，我们不大会碰到表空间不够用的情况。但是，在很多场景，数据的体量是不断的增长的。会不断的侵蚀我们分配的表空间，此时会出现
表空间不够用的情况，那么就需要我们增加表空间的大小。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#增加一个表空间文件，大小为20000M
ALTER TABLESPACE SYSTEM ADD DATAFILE &amp;#39;C:\***\SYSTEM03.DBF&amp;#39; SIZE 20000M;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查询表空间大小&lt;/h3&gt;

&lt;p&gt;在Oracle中，表空间的信息都储存在&lt;code&gt;DBA_DATA_FILES&lt;/code&gt;。我们可以通过此表来算出表空间文件的大小。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#查询表空间大小
SELECT TABLESPACE_NAME, ROUND(SUM(BYTES/(1024*1024)),0) AS TS_SIZE FROM DBA_DATA_FILES GROUP BY TABLESPACE_NAME;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>从二次型最优化问题中理解矩阵特征值的意义</title>
        <link>http://eledata.github.io/2015/09/12/Intuition-of-Eigen-Value.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2015/09/12/Intuition-of-Eigen-Value.html</guid>
        <pubDate>Sat, 12 Sep 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;惯例开场故事&lt;/h3&gt;

&lt;p&gt;在某次从实验室去往食堂的路上，曾发生这样一段对话：&lt;/p&gt;

&lt;p&gt;『大师兄，为什么你对算法的理解总是那么透彻呢？为什么我很难看出它背后的思想？』&lt;/p&gt;

&lt;p&gt;『因为你去理解一个算法的时候，不能只是看懂它的形，还要去思考它的神啊~』&lt;/p&gt;

&lt;p&gt;这就是我天分不够当不了科学家的佐证吧T。T&lt;/p&gt;

&lt;h3&gt;从二次型最优化来理解&lt;/h3&gt;

&lt;p&gt;最小化二次型目标函数&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=x^TAx&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=x^TAx&quot; title=&quot;f(x)=x^TAx&quot; /&gt;&lt;/a&gt;，其中A为已知的实对称二阶矩阵，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=A=[1,0.5;0.5,1]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?A=[1,0.5;0.5,1]&quot; title=&quot;A=[1,0.5;0.5,1]&quot; /&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x=[x_1,x_2]^{\textrm{T}}&amp;space;\in&amp;space;\textcal{R}^2&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x=[x_1,x_2]^{\textrm{T}}&amp;space;\in&amp;space;\textcal{R}^2&quot; title=&quot;x=[x_1,x_2]^{\textrm{T}} \in \textcal{R}^2&quot; /&gt;&lt;/a&gt;.这个问题的求解很简单，这里以此为例来说明该问题与矩阵特征值的关系。&lt;/p&gt;

&lt;p&gt;首先，可以得到目标函数的网格图与等高线图如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/mesh_of_f.png&quot; alt=&quot;1&quot;&gt;
&lt;img src=&quot;/public/img/posts/contour_of_f.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;p&gt;对矩阵A进行特征分解可以得到其特征向量为[-0.7071, 0.7071], [0.7071, 0.7071]，对应的特征值分别是0.5, 1.5.&lt;/p&gt;

&lt;p&gt;观察函数的等高线图可以知道，等高线最密集的地方，函数值变化最快，而这个函数值变化最快的方向归一化后就是[0.7071, 0.7071]，这恰好是矩阵的一个特征向量。同样地，可以观察，等高线最稀疏的地方，函数值变化最慢，变化方向则是矩阵的另一个特征向量。可以看出，&lt;code&gt;矩阵特征值的大小与函数值的变化快慢有关&lt;/code&gt;，较大特征值所对应的特征向量方向上函数值的变化较快，较小特征值所对应的特征向量方向上函数值的变化较慢。&lt;/p&gt;

&lt;p&gt;进一步，对于实对称矩阵，我们总是可以对其进行相似变化，得到一个以该矩阵特征值为对角线元素的对角阵。&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=P^{-1}AP=B&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?P^{-1}AP=B&quot; title=&quot;P^{-1}AP=B&quot; /&gt;&lt;/a&gt;，其中，P为正交矩阵，有性质P的逆等于P的转置。把目标函数改写为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; title=&quot;f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; /&gt;&lt;/a&gt;，其中&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=B=[0.5,&amp;space;0;&amp;space;0,&amp;space;1.5]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?B=[0.5,&amp;space;0;&amp;space;0,&amp;space;1.5]&quot; title=&quot;B=[0.5, 0; 0, 1.5]&quot; /&gt;&lt;/a&gt;. 相似变换的作用可以理解为将等高线图进行旋转，于是得到下面经过旋转后的等高线图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/contour_of_f_B.png&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这张图上说明矩阵特征值的意义。当函数值取1时所对应的椭圆等高线的长轴长度为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\frac{1}{\sqrt{0.5}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\frac{1}{\sqrt{0.5}}&quot; title=&quot;\frac{1}{\sqrt{0.5}}&quot; /&gt;&lt;/a&gt;， 即由矩阵特征值0.5决定。同理，该椭圆短轴长度为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\frac{1}{\sqrt{1.5}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\frac{1}{\sqrt{1.5}}&quot; title=&quot;\frac{1}{\sqrt{1.5}}&quot; /&gt;&lt;/a&gt;，由矩阵特征值1.5决定。&lt;/p&gt;

&lt;p&gt;二阶矩阵的理解较为直观。高阶矩阵的道理是一样的。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.zhihu.com/question/21874816/answer/19592526&quot;&gt;如何理解矩阵特征值&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac以及Windows上搭建C++工作环境</title>
        <link>http://eledata.github.io/2015/02/13/Cplus-on-MAC.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2015/02/13/Cplus-on-MAC.html</guid>
        <pubDate>Fri, 13 Feb 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;实验室里我申请的垃圾老爷机被师弟玩坏了，弄了一天，最后发现根本就是硬件损伤，想把它砸掉！太坑了。&lt;/p&gt;

&lt;p&gt;clang是osx自带的c,c++,objective-c编译器；gnu是常用的c++的轻量级编译器，在windows上通常是下载MinGW；sublime就不多说了；本文的目的就是搭建一个轻量级的C++编辑-编译-调试-运行环境。&lt;/p&gt;

&lt;h2&gt;MAC上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开sublime，&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入install，选择&lt;code&gt;install package&lt;/code&gt;，回车&lt;/li&gt;
&lt;li&gt;输入sublimeClang，回车下载&lt;/li&gt;
&lt;li&gt;编写一个简单的c++程序，保存为name.cpp&lt;/li&gt;
&lt;li&gt;在terminal中，&lt;code&gt;clang++ name.cpp -o name&lt;/code&gt;或者&lt;code&gt;g++ name.cpp -o name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;双击name运行&lt;/li&gt;
&lt;li&gt;如果运行过程不需要输入数据，可以直接在sublime中&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt;运行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;AppStore中下载Xcode&lt;/li&gt;
&lt;li&gt;使用这个IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;WINDOWS上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装Installation Manager，运行，选择需要下载的组件，比如这里需要C++有关的组件&lt;/li&gt;
&lt;li&gt;将MinGW的安装路径添加到环境变量中&lt;/li&gt;
&lt;li&gt;cmd中输入&lt;code&gt;g++ -v&lt;/code&gt;来检测gnu是否安装成功&lt;/li&gt;
&lt;li&gt;打开sublime text 3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;browse packages&lt;/code&gt;-&amp;gt;&lt;code&gt;gcc&lt;/code&gt;(好像是这样，反正自己摸索就好了)&lt;/li&gt;
&lt;li&gt;OK，完成&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Visual Studio&lt;/li&gt;
&lt;li&gt;使用该IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;有用的资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/g++/index.html&quot;&gt;Writing and Running C++ Programs in the UNIX Environment using g++&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/xCode_Instructions/index.html&quot;&gt;Writing and Running C++ Programs in the Mac OS X 10.4 Environment using xCode&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Git常用命令速查表</title>
        <link>http://eledata.github.io/2015/01/30/Git-Resources.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2015/01/30/Git-Resources.html</guid>
        <pubDate>Fri, 30 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;master: 默认开发分支&lt;/p&gt;

&lt;p&gt;origin: 默认远程版本库&lt;/p&gt;

&lt;p&gt;Head: 默认开发分支&lt;/p&gt;

&lt;p&gt;Head^: Head的父提交&lt;/p&gt;

&lt;h3&gt;创建版本库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git clone &amp;lt;url&amp;gt;   #克隆远程版本库
$ git init          #初始化本地版本库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改和提交&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git status        #查看状态
$ git diff          #查看变更内容
$ git add .         #跟踪所有改动过的文件
$ git add &amp;lt;file&amp;gt;    #跟踪指定的文件
$ git mv &amp;lt;old&amp;gt;&amp;lt;new&amp;gt; #文件改名
$ git rm&amp;lt;file&amp;gt;      #删除文件
$ git rm --cached&amp;lt;file&amp;gt;            #停止跟踪文件但不删除
$ git commit -m &amp;quot;commit messages&amp;quot;  #提交所有更新过的文件
$ git commit --amend               #修改最后一次改动
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看提交历史&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git log                    #查看提交历史
$ git log -p &amp;lt;file&amp;gt;          #查看指定文件的提交历史
$ git blame &amp;lt;file&amp;gt;           #以列表方式查看指定文件的提交历史
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;撤销&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git reset --hard HEAD      #撤销工作目录中所有未提交文件的修改内容
$ git checkout HEAD &amp;lt;file&amp;gt;   #撤销指定的未提交文件的修改内容
$ git revert &amp;lt;commit&amp;gt;        #撤销指定的提交
$ git log --before=&amp;quot;1 days&amp;quot;  #退回到之前1天的版本 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分支与标签&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch                   #显示所有本地分支
$ git checkout &amp;lt;branch/tag&amp;gt;    #切换到指定分支和标签
$ git branch &amp;lt;new-branch&amp;gt;      #创建新分支
$ git branch -d &amp;lt;branch&amp;gt;       #删除本地分支
$ git tag                      #列出所有本地标签
$ git tag &amp;lt;tagname&amp;gt;            #基于最新提交创建标签
$ git tag -d &amp;lt;tagname&amp;gt;         #删除标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;合并与衍合&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git merge &amp;lt;branch&amp;gt;        #合并指定分支到当前分支
$ git rebase &amp;lt;branch&amp;gt;       #衍合指定分支到当前分支
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;远程操作&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git remote -v                   #查看远程版本库信息
$ git remote show &amp;lt;remote&amp;gt;        #查看指定远程版本库信息
$ git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;   #添加远程版本库
$ git fetch &amp;lt;remote&amp;gt;              #从远程库获取代码
$ git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #下载代码及快速合并
$ git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #上传代码及快速合并
$ git push &amp;lt;remote&amp;gt; :&amp;lt;branch/tag-name&amp;gt;  #删除远程分支或标签
$ git push --tags                       #上传所有标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;资料链接&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://try.github.io/levels/1/challenges/1&quot;&gt;Try Git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>2015年阅读书单</title>
        <link>http://eledata.github.io/2015/01/29/Book-List-2015.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2015/01/29/Book-List-2015.html</guid>
        <pubDate>Thu, 29 Jan 2015 00:00:00 +0800</pubDate>
        <description></description>
      </item>
    
      <item>
        <title>在Mac上用LaTeX写漂亮的简历</title>
        <link>http://eledata.github.io/2014/12/06/Make-resume-by-LaTeX.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/12/06/Make-resume-by-LaTeX.html</guid>
        <pubDate>Sat, 06 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/resume.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;你会搜索查看到这篇文章，相信就不需要我解释为什么要用LaTeX写Resume了：）&lt;/p&gt;

&lt;p&gt;今晚报名Facebook China Tech Talk，最后一步需要上传简历。看着已经2年没有更新过的简历，好捉急。那时真是年轻，不舍得做减法，恨不能一张A4纸写尽一生。于是索性重新制作一份简历。&lt;/p&gt;

&lt;h3&gt;需要准备&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装好的LaTeX，如果没有安装请参考&lt;a href=&quot;http://painterlin.com/2014/08/10/Using-LaTeX-with-Sublime-and-Skim-for-Mac.html&quot;&gt;在Mac上通过Sublime、Skim编辑LaTeX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互联网&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rpi.edu/dept/arc/training/latex/resumes/&quot;&gt;Using the LaTeX Resume Templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.latextemplates.com/cat/curricula-vitae&quot;&gt;LaTeX Templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在上述资料中寻找自己喜欢的模板&lt;/li&gt;
&lt;li&gt;下载模板对应的tex文件&lt;/li&gt;
&lt;li&gt;用LaTeX打开对应文件，编辑，编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候，如果你使用的是Mac系统，非常不幸，大多数情况下都将编译失败。因为网上多数模板需要使用windows环境下的Tex应用程序，而Mac环境下MacTex应用程序会缺少部分文件。没关系，我们有办法解决。&lt;/p&gt;

&lt;h3&gt;解决方案一：moderncv&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.ctan.org/pkg/moderncv&quot;&gt;http://www.ctan.org/pkg/moderncv &lt;/a&gt;下载&lt;code&gt;moderncv package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解压，找到模板文件&lt;code&gt;template.tex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用已经安装好的LaTeX打开模板文件，编辑，编译，成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是呢，我个人觉得moderncv模板并不够好，虽然其结构清新简洁，但布局过于稀疏。没关系，我们仍然有办法。感谢一个我无意中发现的网站：ShareLaTeX.com&lt;/p&gt;

&lt;h3&gt;解决方案二：ShareLaTeX.com&lt;/h3&gt;

&lt;p&gt;也许你在上面的资料中找到了你最喜欢的模板，却苦于在Mac OS X系统下无法编译成功。这时可以求助于&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，这是一个在线LaTeX编辑网站，并且提供&lt;code&gt;Resume&lt;/code&gt;,&lt;code&gt;Cover Letter&lt;/code&gt;,&lt;code&gt;Journal Article&lt;/code&gt;,&lt;code&gt;Presentation&lt;/code&gt;,&lt;code&gt;Thesis&lt;/code&gt;,&lt;code&gt;Bibliographies&lt;/code&gt;等不同分类的多种模板。最重要的一点事，只需要确定Latex语法无误，再也不需担心什么编译环境、文件缺失等乱七八糟的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，注册账号&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;New Project&lt;/code&gt;，选择&lt;code&gt;CV or Resume&lt;/code&gt;，挑选你喜欢的简历模板&lt;/li&gt;
&lt;li&gt;根据自己的情况编辑，自动或手动编译，保存PDF&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;既然写到这里了，还想讲讲自己对于简历的体会。但我真的是困得不行了。。。。北京第一次不归夜。。。改天再来补全。。。。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Yosemite OS X 10.10 Matlab 2012a停止工作的解决办法</title>
        <link>http://eledata.github.io/2014/10/31/Yosemite-Matlab-Running-Error.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/10/31/Yosemite-Matlab-Running-Error.html</guid>
        <pubDate>Fri, 31 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;OS X 系统更新到Yosemite后，Matlab 2012a就无法运行了。&lt;/p&gt;

&lt;h3&gt;解决步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://xquartz.macosforge.org/landing/&quot;&gt;XQuartz&lt;/a&gt;下载&lt;code&gt;XQuartz-2.7.7.dmg&lt;/code&gt;，并安装更新。&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行命令：&lt;code&gt;
sudo ln -s /opt/X11/ /usr/X11
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载并安装&lt;a href=&quot;http://support.apple.com/kb/DL1572&quot;&gt;Java 6&lt;/a&gt;更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;完成✌️&lt;/h3&gt;

&lt;p&gt;OK，现在Matlab就能重新工作了。&lt;/p&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://brainsuite.org/quickstart/installation/mac/yosemite/&quot;&gt; running svreg and bdp on yosemite (os x 10.10)&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac安装unrar和rar解压缩工具</title>
        <link>http://eledata.github.io/2014/10/07/Mac-Rar-Unrar.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/10/07/Mac-Rar-Unrar.html</guid>
        <pubDate>Tue, 07 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;Mac不能解压rar文件，但实际中会需要这项功能。比如从邮件中的附件时常以rar文件格式传输。&lt;/p&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.rarlab.com/download.htm&quot;&gt;rarlab&lt;/a&gt;下载&lt;code&gt;RAR 5.20 beta 1 for Mac OS X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行解压缩命令：tar xvfz rarosx-5.2.b1.tar进行解压&lt;/li&gt;
&lt;li&gt;进入刚刚解压的rar目录中，cd downloads/rar&lt;/li&gt;
&lt;li&gt;在rar目录下使用如下命令进行安装&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo install -c -o$USER unrar /bin
sudo install -c -o$USER rar /bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;解压与压缩&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;unrar x filename.rar             #解压
rar a archivename.rar filename   #压缩
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;为什么要折腾这个，因为今天收到一份rar格式的文件。
转眼一年了，好快啊。这是要每年送我一个生日蛋糕的节奏吗？如果是的话，这篇博客需要每年更新一次。&lt;/p&gt;

&lt;h4&gt;2013年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2014年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2015年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/3.jpg&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;h3&gt;谢意&lt;/h3&gt;

&lt;p&gt;蒲俊楠童鞋，阿里嘎多~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Learn Algorithms Ten - Dynamic programming</title>
        <link>http://eledata.github.io/2014/10/02/Learn-Algorithms-Ten.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/10/02/Learn-Algorithms-Ten.html</guid>
        <pubDate>Thu, 02 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;10.1 Dynamic programming&lt;/p&gt;

&lt;p&gt;What is the Dynamic programming?&lt;/p&gt;

&lt;p&gt;Dynamic programming, like the divide-and-conquer method, solves problems by combining the solutions to subproblems.&lt;/p&gt;

&lt;p&gt;A Dynamic programming algorithm solves every subsubproblem just once and then saves its anser in a table, thereby avoiding the work of recomputing the answer every tiem the subsubproblem is encountered.&lt;/p&gt;

&lt;p&gt;There are four steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Characterize the structure of an optimal solution&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recursively define the value of an optimal solution&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compute the value of an optimal solution in a bottom-up fashion&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Construct an optimal solution from computed information&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;10.1.1 Assembly-Line scheduling&lt;/p&gt;

&lt;p&gt;There four steps to assolve this problem:&lt;/p&gt;

&lt;p&gt;Step 1: The structure of the fastest way through the factory.&lt;/p&gt;

&lt;p&gt;Step 2: A recursive solution.&lt;/p&gt;

&lt;p&gt;Step 3: Computing the fastest times.&lt;/p&gt;

&lt;p&gt;Step 4: Constructing the fastest way through the factory.&lt;/p&gt;

&lt;p&gt;Assembly&lt;em&gt;Line&lt;/em&gt;Scheduling Code:
```
    #include &lt;iostream&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;using namespace std;

void dynamic_assline_schedule()
{
  int i,j;
    int temp;
    int schedule_rec_one[10] = {0};
    int schedule_rec_two[10] = {0};
    int tot_time[2][10];
    int ass_station_time_assumption[2][10];
    int ass_sta_tranfer_time_assumption[2][10];

    temp = 0;
    memset(tot_time,0,sizeof(tot_time));
    memset(ass_station_time_assumption,0,sizeof(ass_station_time_assumption));
    memset(ass_sta_tranfer_time_assumption,0,sizeof(ass_sta_tranfer_time_assumption));

    cout &amp;lt;&amp;lt; &amp;quot;ass_station_time_assumption:&amp;quot; &amp;lt;&amp;lt; endl;
/*  for(i = 1; i &amp;lt;= 2; i++)
    {
        if (i == 1)
        {
            cout &amp;lt;&amp;lt; &amp;quot;Station One:&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;Station Two:&amp;quot; &amp;lt;&amp;lt; endl;
        }

        for(j = 1; j &amp;lt;= 6; j++)
        {
            cin &amp;gt;&amp;gt; ass_station_time_assumption[i][j];
        }

    }

    cout &amp;lt;&amp;lt; &amp;quot;ass_sta_tranfer_time_assumption:&amp;quot; &amp;lt;&amp;lt; endl;

    for(i = 1; i &amp;lt;= 2; i++)
    {
        if (i == 1)
        {
            cout &amp;lt;&amp;lt; &amp;quot;Transfer One:&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;Transfer Two:&amp;quot; &amp;lt;&amp;lt; endl;
        }

        for(j = 1; j &amp;lt;= 7; j++)
        {
            cin &amp;gt;&amp;gt; ass_sta_tranfer_time_assumption[i][j];
        }
    }*/
    ass_station_time_assumption[1][1] = 7;
    ass_station_time_assumption[1][2] = 9;
    ass_station_time_assumption[1][3] = 3;
    ass_station_time_assumption[1][4] = 4;
    ass_station_time_assumption[1][5] = 8;
    ass_station_time_assumption[1][6] = 4;

    ass_station_time_assumption[2][1] = 8;
    ass_station_time_assumption[2][2] = 5;
    ass_station_time_assumption[2][3] = 6;
    ass_station_time_assumption[2][4] = 4;
    ass_station_time_assumption[2][5] = 5;
    ass_station_time_assumption[2][6] = 7;

    ass_sta_tranfer_time_assumption[1][1] = 2;
    ass_sta_tranfer_time_assumption[1][2] = 2;
    ass_sta_tranfer_time_assumption[1][3] = 3;
    ass_sta_tranfer_time_assumption[1][4] = 1;
    ass_sta_tranfer_time_assumption[1][5] = 3;
    ass_sta_tranfer_time_assumption[1][6] = 4;
    ass_sta_tranfer_time_assumption[1][7] = 3;

    ass_sta_tranfer_time_assumption[2][1] = 4;
    ass_sta_tranfer_time_assumption[2][2] = 2;
    ass_sta_tranfer_time_assumption[2][3] = 1;
    ass_sta_tranfer_time_assumption[2][4] = 2;
    ass_sta_tranfer_time_assumption[2][5] = 2;
    ass_sta_tranfer_time_assumption[2][6] = 1;
    ass_sta_tranfer_time_assumption[2][7] = 2;

    schedule_rec_one[1] = 1;
    schedule_rec_two[1] = 2;

    tot_time[1][1] = ass_station_time_assumption[1][1] + ass_sta_tranfer_time_assumption[1][1]; //9
    tot_time[2][1] = ass_station_time_assumption[2][1] + ass_sta_tranfer_time_assumption[2][1]; //12

    for(i = 2; i &amp;lt;= 6; i++)
    {
        if ((tot_time[1][i - 1] + ass_station_time_assumption[1][i]) &amp;lt; (tot_time[2][i - 1] + ass_sta_tranfer_time_assumption[2][i] + ass_station_time_assumption[1][i]))
        {
            schedule_rec_one[i] = 1;
            temp = (tot_time[1][i - 1] + ass_station_time_assumption[1][i]);
            tot_time[1][i] = temp;
        }
        else
        {
            schedule_rec_one[i] = 2;
            temp = (tot_time[2][i - 1] + ass_sta_tranfer_time_assumption[2][i] + ass_station_time_assumption[1][i]);
            tot_time[1][i] = temp;
        }

        if ((tot_time[2][i - 1] + ass_station_time_assumption[2][i]) &amp;lt; (tot_time[1][i - 1] + ass_sta_tranfer_time_assumption[1][i] + ass_station_time_assumption[2][i]))
        {
            schedule_rec_two[i] = 2;
            temp = (tot_time[2][i - 1] + ass_station_time_assumption[2][i]);
            tot_time[2][i] = temp;
        }
        else
        {
            schedule_rec_two[i] = 1;
            temp = (tot_time[1][i - 1] + ass_sta_tranfer_time_assumption[1][i] + ass_station_time_assumption[2][i]);
            tot_time[2][i] = temp;
        }
    }

    if (tot_time[1][6] &amp;lt; tot_time[2][6])
    {
        tot_time[1][7] = tot_time[1][6] + ass_sta_tranfer_time_assumption[1][7];
        schedule_rec_one[7] = 1;
        cout &amp;lt;&amp;lt; &amp;quot;Schedule one use time:&amp;quot;&amp;lt;&amp;lt; tot_time[1][7] &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;Trace:&amp;quot; &amp;lt;&amp;lt; endl;
        for(i = 1; i &amp;lt;= 7; i++)
        {
            cout &amp;lt;&amp;lt; schedule_rec_one[i] &amp;lt;&amp;lt; &amp;quot;_&amp;quot;;
        }
    }
    else
    {
        tot_time[2][7] = tot_time[2][6] + ass_sta_tranfer_time_assumption[2][7];
        schedule_rec_two[7] = 2;
        cout &amp;lt;&amp;lt; &amp;quot;Schedule two use time:&amp;quot;&amp;lt;&amp;lt; tot_time[1][7] &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;Trace:&amp;quot; &amp;lt;&amp;lt; endl;
        for(i = 1; i &amp;lt;= 7; i++)
        {
            cout &amp;lt;&amp;lt; schedule_rec_two[i] &amp;lt;&amp;lt; &amp;quot;_&amp;quot;;
        }
    }
}

int main()
{
    cout&amp;lt;&amp;lt;&amp;quot;Dynamic Schedule:&amp;quot; &amp;lt;&amp;lt; endl;
    dynamic_assline_schedule();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;10.1.2 Matrix-chain multiplication
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Linux 4：磁盘与文件系统管理</title>
        <link>http://eledata.github.io/2014/09/30/Linux4.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/30/Linux4.html</guid>
        <pubDate>Tue, 30 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;认识EXT2文件系统&lt;/h3&gt;

&lt;p&gt;每种操作系统能够使用的文件系统并不相同。 举例来说，windows 98以前的微软操作系统主要利用的文件系统是&lt;code&gt;FAT(或FAT16)&lt;/code&gt;，windows 2000以后的版本有所谓的&lt;code&gt;NTFS&lt;/code&gt;文件系统，至于Linux的正统文件系统则为&lt;code&gt;Ext2&lt;/code&gt;(Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows操作系统是不会认识Linux的Ext2的。&lt;/p&gt;

&lt;p&gt;那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到&lt;code&gt;inode&lt;/code&gt;中，至于实际数据则放置到&lt;code&gt;data block&lt;/code&gt;区块中。 另外，还有一个超级区块(&lt;code&gt;superblock&lt;/code&gt;)会记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等。&lt;/p&gt;

&lt;h3&gt;文件系统的简单操作&lt;/h3&gt;

&lt;h3&gt;磁盘的分割、格式化、检验与挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;磁盘分区： fdisk, partprobe&lt;/li&gt;
&lt;li&gt;磁盘格式化： mkfs, mke2fs&lt;/li&gt;
&lt;li&gt;磁盘检验： fsck, badblocks&lt;/li&gt;
&lt;li&gt;磁盘挂载与卸除： mount, umount&lt;/li&gt;
&lt;li&gt;磁盘参数修订： mknod, e2label, tune2fs, hdparm&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置启动挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;启动挂载 /etc/fstab 及 /etc/mtab&lt;/li&gt;
&lt;li&gt;特殊装置 loop 挂载(映象档不刻录就挂载使用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;内存置换空间(swap)之建置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用实体分割槽建置swap&lt;/li&gt;
&lt;li&gt;使用文件建置swap&lt;/li&gt;
&lt;li&gt;swap使用上的限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;文件系统的特殊观察与操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;boot sector 与 superblock 的关系&lt;/li&gt;
&lt;li&gt;磁盘空间之浪费问题&lt;/li&gt;
&lt;li&gt;利用 GNU 的 parted 进行分割行为&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;重点回顾&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本上 Linux 的正统文件系统为 Ext2 ，该文件系统内的信息主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；&lt;/li&gt;
&lt;li&gt;inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；&lt;/li&gt;
&lt;li&gt;block：实际记录文件的内容，若文件太大时，会占用多个 block 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2 文件系统的数据存取为索引式文件系统(indexed allocation)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;inode 记录文件的属性/权限等数据，其他重要项目为： 每个 inode 大小均固定为 128 bytes； 每个文件都仅会占用一个 inode 而已； 因此文件系统能够创建的文件数量与 inode 的数量有关；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录底下文件名与其 inode 号码的对照表；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志式文件系统 (journal) 会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux 文件系统为添加效能，会让主存储器作为大量的磁盘高速缓存；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实体链接只是多了一个文件名对该 inode 号码的链接而已；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;符号链接就类似Windows的快捷方式功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘的使用必需要经过：分割、格式化与挂载，分别惯用的命令为：fdisk, mkfs, mount三个命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动自动挂载可参考/etc/fstab之配置，配置完毕务必使用 mount -a 测试语法正确否；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem.php#harddisk&quot;&gt;鸟哥的Linux私房菜 第八章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Learn Statistics One</title>
        <link>http://eledata.github.io/2014/09/27/Learn-Statistics-One.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/27/Learn-Statistics-One.html</guid>
        <pubDate>Sat, 27 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;hr&gt;

&lt;p&gt;layout: post
keywords: Statistics
description: Learn Statistics
title: &amp;quot;Learn Statistics One&amp;quot;
categories: Statistics C++&amp;amp;Python
tags: Statistics
group: archive&lt;/p&gt;

&lt;h2&gt;icon: key&lt;/h2&gt;

&lt;h1&gt;Session 1&lt;/h1&gt;

&lt;p&gt;1.1 Basic concepts
What is Statistics?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Statistics&lt;/strong&gt; is the study of the collection,organization analysis, interpretation, presentation and orgasim of data.[1] It deals with all aspects of data including the planning of data collection in terms of the design of surveys and experiments.[1] When analyzing data, it is possible to use one of two statistics methodologies: descriptive statistics or inferential statistics.&lt;/p&gt;

&lt;p&gt;Descriptive statistics can be used to summarize the population data. Numerical descriptors include mean and standard deviation for continuous data types (like income), while frequency and percentage are more useful in terms of describing categorical data (like race).&lt;/p&gt;

&lt;p&gt;When you click the &lt;strong&gt;Knit HTML&lt;/strong&gt; button a web page will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;kp&quot;&gt;summary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;##      speed           dist    
##  Min.   : 4.0   Min.   :  2  
##  1st Qu.:12.0   1st Qu.: 26  
##  Median :15.0   Median : 36  
##  Mean   :15.4   Mean   : 43  
##  3rd Qu.:19.0   3rd Qu.: 56  
##  Max.   :25.0   Max.   :120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can also embed plots, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Learn Algorithms One</title>
        <link>http://eledata.github.io/2014/09/27/Learn-Algorithms-One.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/27/Learn-Algorithms-One.html</guid>
        <pubDate>Sat, 27 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1.1 Algorithms&lt;/p&gt;

&lt;p&gt;What is the algorithms?&lt;/p&gt;

&lt;p&gt;An algorithms is thus a sequence of computational steps that transform the input into the output.&lt;/p&gt;

&lt;p&gt;Data Structure&lt;/p&gt;

&lt;p&gt;A data structure is a way to store and organize data in order to facilitate access and modifications. No single data structure works well for all purposes, and so it is important to know the strenghs and limitations of several of them.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Six</title>
        <link>http://eledata.github.io/2014/09/20/Learn-Python-Exercise-Six.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/20/Learn-Python-Exercise-Six.html</guid>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Data Structure:&lt;/p&gt;

&lt;p&gt;This session show how to use the list, set, tuple, dict, looping etc.&lt;/p&gt;

&lt;p&gt;learn_datastructure.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/21/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
Data Type
List example:
[&amp;quot;list1&amp;quot;,&amp;quot;list2&amp;quot;,&amp;quot;list3&amp;quot;]

list.append(x)
Add an item to the end of the list; equivalent to a[len(a):] = [x].

list.extend(L)
Extend the list by appending all the items in the given list; equivalent to a[len(a):] = L.

list.insert(i, x)
Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x).

list.remove(x)
Remove the first item from the list whose value is x. It is an error if there is no such item.

list.pop([i])
Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.)

list.index(x)
Return the index in the list of the first item whose value is x. It is an error if there is no such item.

list.count(x)
Return the number of times x appears in the list.

list.sort(cmp=None, key=None, reverse=False)
Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for their explanation).

list.reverse()
Reverse the elements of the list, in place.
&amp;quot;&amp;quot;&amp;quot;
def listType(params):
    print(&amp;quot;print list items below:&amp;quot;)

    for i in params:
        print i, len(i)

def my_reverse(x,y):
    if x &amp;gt; y:
        return -1
    if x &amp;lt; y:
        return 1
    return 0

def filter_func(x):
    return x%2 != 0 and x%3 !=0

def reduce_add(x,y):
    return  x + y

def map_add(x):
    return x + x

def char2int(str):
    return {&amp;#39;0&amp;#39;: 0, &amp;#39;1&amp;#39;: 1, &amp;#39;2&amp;#39;: 2, &amp;#39;3&amp;#39;: 3, &amp;#39;4&amp;#39;: 4, &amp;#39;5&amp;#39;: 5, &amp;#39;6&amp;#39;: 6, &amp;#39;7&amp;#39;: 7, &amp;#39;8&amp;#39;: 8, &amp;#39;9&amp;#39;: 9}[str]

def str2int(str):
    return reduce(lambda x, y: x * 10 + y, map(char2int, str))

&amp;quot;&amp;quot;&amp;quot;
Tuple:
tup = (1,2,3,4,5)
Very like to list. But tuple is immutable!
&amp;quot;&amp;quot;&amp;quot;
def show_tuple_structure():

    tup_one = 1,2,3,4,5
    tup_two = 1235,&amp;#39;tuple_item&amp;#39;
    tup_three = tup_one, tup_two
    tup_list = ([1,2,3],[5,6,7])
    tup_four = &amp;#39;hello_tuple&amp;#39;,

    print &amp;quot;Print tuple:&amp;quot;
    print tup_one
    print tup_two
    print tup_three
    print tup_list
    print tup_four

&amp;quot;&amp;quot;&amp;quot;
Set:
A set is an unordered collection with no duplicate elements. 
Basic uses include membership testing and eliminating duplicate entries.
Set objects also support mathematical operations like union, intersection, difference, and symmetric difference.
set(list)
&amp;quot;&amp;quot;&amp;quot;
def show_set_structure():
    print &amp;quot;set:&amp;quot;
    basket = [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;apple&amp;#39;, &amp;#39;pear&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;banana&amp;#39;]
    print basket
    set(basket)
    print basket

    set_a = set(&amp;#39;abracadabra&amp;#39;)
    set_b = set(&amp;#39;alacazam&amp;#39;)
    # use operations, monitor the set operations
    print &amp;quot;set_a, set_b:&amp;quot;,set_a, set_b
    print &amp;quot;set_a - set_b:&amp;quot;, set_a - set_b
    print &amp;quot;set_a | b:&amp;quot;, set_a|set_b
    print &amp;quot;set_a &amp;amp; set_b:&amp;quot;, set_a&amp;amp;set_b
    print &amp;quot;set_a ^ set_b:&amp;quot;, set_a ^ set_b


&amp;quot;&amp;quot;&amp;quot;
Data type
Dictionary
    It define key-value relationship. {key, value}
    Example:
    {&amp;quot;server&amp;quot;:&amp;quot;huangmoyue&amp;quot;, &amp;quot;pwd&amp;quot;:&amp;quot;12345&amp;quot;}
&amp;quot;&amp;quot;&amp;quot;

def dictionaryType():
    print(&amp;quot;dic type:&amp;quot;)

    dic_a = {&amp;quot;Server&amp;quot;:&amp;quot;huangmoyue&amp;quot;,&amp;quot;Pwd&amp;quot;:&amp;quot;861117&amp;quot;}
    dic_b = {&amp;#39;jack&amp;#39;: 4098, &amp;#39;sape&amp;#39;: 4139}

    print dic_a.keys()
    print dic_b[&amp;quot;jack&amp;quot;]

    for key, value in dic_a.items():
        print(&amp;quot;;&amp;quot;.join((key, value)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;testing_datastructure.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/21/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

import unittest
from unittest import TestCase

from learnpy.learning_datastructure import listType
from learnpy.learning_datastructure import my_reverse
from learnpy.learning_datastructure import filter_func
from learnpy.learning_datastructure import reduce_add
from learnpy.learning_datastructure import map_add
from learnpy.learning_datastructure import str2int
from learnpy.learning_datastructure import show_tuple_structure
from learnpy.learning_datastructure import show_set_structure
from learnpy.learning_datastructure import dictionaryType

class Test_DataType(TestCase):
    def test_listtype(self):
        test_list = [&amp;quot;list1&amp;quot;,&amp;quot;list2&amp;quot;,&amp;quot;list3&amp;quot;]
        listType(test_list)

    def test_list_inernal_function(self):
        test_list = [66.25, 333, 333, 1, 1234.5]

        #append 100 behind the test_list
        test_list.append(100)
        print &amp;quot;append 100 behind:&amp;quot;, test_list

        #extend 
        ex_list = [&amp;quot;extend_item1&amp;quot;, &amp;quot;extend_item2&amp;quot;]
        test_list.extend(ex_list)
        print &amp;quot;extend two items:&amp;quot;, test_list

        #insert
        test_list.insert(3,&amp;quot;insert_item&amp;quot;)
        print &amp;quot;insert one item:&amp;quot;, test_list

        #remove
        test_list.remove(333)
        print &amp;quot;remove 333 from test_list:&amp;quot;,test_list

        #pop
        test_list.pop()
        print &amp;quot;Use pop funtion:&amp;quot;,test_list
        test_list.pop(0)
        print &amp;quot;Use pop to remove 66.25:&amp;quot;,test_list

        #index
        print &amp;quot;Show index(0) position:&amp;quot;, test_list.index(1)

        #count
        print &amp;quot;Show the extend_item1 position:&amp;quot;, test_list.count(&amp;quot;extend_item1&amp;quot;)

        #sort
        print &amp;quot;Show before:&amp;quot;,test_list
        test_list.sort()
        print &amp;quot;Show sort after:&amp;quot;,test_list

        #sorted use user define function
        print &amp;quot;Show before:&amp;quot;, test_list
        sorted(test_list,my_reverse)
        print &amp;quot;Show my own sort function:&amp;quot;,sorted(test_list,my_reverse)

    #filter(function, sequence) returns a sequence consisting of those items from the sequence for which function(item) is true. If sequence is a string or tuple, the result will be of the same type; otherwise, it is always a list. 
    #map(function, sequence) calls function(item) for each of the sequence’s items and returns a list of the return values. 
    #reduce(function, sequence) returns a single value constructed by calling the binary function function on the first two items of the sequence, then on the result and the next item, and so on.
    def test_functional_tools(self):
        print &amp;quot;Show how to use the filter:&amp;quot;, filter(filter_func,range(2,25))
        print &amp;quot;Show how to use the reduece:&amp;quot;,reduce(reduce_add, [1, 3, 5, 7, 9])
        print &amp;quot;Show how to use the map:&amp;quot;, map(map_add, [1, 2, 3, 4, 5, 6, 7, 8, 9])
        print &amp;quot;Show how the map and reduece work together:&amp;quot;, str2int(&amp;quot;123456&amp;quot;)


    #List comprehensions
    def test_list_comprehensions(self):
        #The tranditional way to create the list

        print &amp;quot;List Comprehensions:&amp;quot;
        test_tra_list = []
        for x in range(10):
            test_tra_list.append(x)
        print test_tra_list

        #Obtain the same value in list
        test_comprehensions_list = [x for x in range(10)]
        print test_comprehensions_list

        #Another case
        test_comb_list = []
        for x in [1,2,3]:
            for y in [3,1,4]:
                if x != y:
                    test_comb_list.append((x,y))

        print test_comb_list        

        test_pre_comb_list = [(x,y) for x in [1,2,3] for y in [2,1,4] if x != y]
        print test_pre_comb_list

    #Nested List Comprehensions
    def test_list_nested_compreh(self):
        print &amp;quot;nested List comprehension:&amp;quot;
        matrix = [
                  [1,2,3,4],
                  [5,6,7,8],
                  [9,10,11,12],
                  [13,14,15,16]
                  ]
        #Some matrix tranform methods:
        tran_one = [[row[i] for row in matrix] for i in range(4)]
        print &amp;quot;tran_one:&amp;quot;, tran_one

        tran_two = zip(*matrix)
        print &amp;quot;tran_two:&amp;quot;, tran_two

        tran_three = []
        for i in range(4):
            tran_three.append([row[i] for row in matrix])
        print &amp;quot;tran_three&amp;quot;, tran_three

        tran_four = []
        for i in range(4):
            tran_four_row = []
            for row in matrix:
                tran_four_row.append(row[i])
            tran_four.append(tran_four_row)
        print &amp;quot;tran_four:&amp;quot;, tran_four

    #Use del to remove the list item
    def test_del(self):
        print &amp;quot;del item:&amp;quot;
        test_list = [&amp;quot;list1&amp;quot;,&amp;quot;list2&amp;quot;,&amp;quot;list3&amp;quot;]
        print test_list
        del test_list[0]
        print test_list

        del test_list       

    # tuple
    def test_tuple(self):
        show_tuple_structure()

    #set
    def test_set(self):
        show_set_structure()
        #set comprehensions
        test_set_compre = {x for x in &amp;#39;abracadabra&amp;#39; if x not in &amp;#39;abc&amp;#39;}
        print &amp;quot;set comprehensions:&amp;quot;,test_set_compre

    #Dict
    def test_dict(self):
        dictionaryType()
        #The dict() constructor builds dictionaries directly from sequences of key-value pairs
        print &amp;quot;Use the dict() constructor to build the dict:&amp;quot;
        print dict(sape=4139, guido=4127, jack=4098)
        print dict([(&amp;#39;sape&amp;#39;, 4139), (&amp;#39;guido&amp;#39;, 4127), (&amp;#39;jack&amp;#39;, 4098)])
        print {x: x**2 for x in (2, 4, 6)}

    #Looping Techniques
    def test_looping(self):
        print &amp;quot;test Loop:&amp;quot;
        print &amp;quot;Use Enumerate:&amp;quot;
        for i, v in enumerate([&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;]):
            print i, v

        print &amp;quot;show two or more sequence one time:&amp;quot;
        questions = [&amp;#39;name&amp;#39;, &amp;#39;quest&amp;#39;, &amp;#39;favorite color&amp;#39;]
        answers = [&amp;#39;lancelot&amp;#39;, &amp;#39;the holy grail&amp;#39;, &amp;#39;blue&amp;#39;]
        for q, a in zip(questions, answers):
            print &amp;quot;what&amp;#39;s your {0}? It is {1}.&amp;quot;.format(q,a)

        print &amp;quot;Show reverse sequence: &amp;quot;
        for i in reversed(range(1,20,2)):
            print i

        print &amp;quot;Show sorted sequence:&amp;quot;
        basket = [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;apple&amp;#39;, &amp;#39;pear&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;banana&amp;#39;]
        for s in sorted(set(basket)):
            print s

        print &amp;quot;Show the dict item&amp;#39;s key-value:&amp;quot;
        dic_a = {&amp;quot;Server&amp;quot;:&amp;quot;huangmoyue&amp;quot;,&amp;quot;Pwd&amp;quot;:&amp;quot;861117&amp;quot;}
        for k, v in dic_a.iteritems():
            print k, v
            print &amp;quot;;&amp;quot;.join((k,v))

    #slicing operations
    def test_slicing(self):
        print &amp;quot;Use slicing:&amp;quot;
        words = [&amp;#39;cat&amp;#39;, &amp;#39;window&amp;#39;, &amp;#39;defenestrate&amp;#39;]
        print words[:]
        print words[2:3]
        print words[-2:-1]


if __name__ == &amp;#39;__main__&amp;#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Seven</title>
        <link>http://eledata.github.io/2014/09/20/Learn-Python-Exercise-Seven.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/20/Learn-Python-Exercise-Seven.html</guid>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Classes&lt;/p&gt;

&lt;p&gt;From python doc&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learning_class.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/20/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
class structure 
class class_name:
    &amp;lt;statement - 1&amp;gt;
    &amp;lt;statement - 1&amp;gt;
&amp;quot;&amp;quot;&amp;quot;

class My_Class:
    #Called when the instance is created. 
    def __init__(self):
        self.data = []

class Complex:
    def __init__(self,realpart,implpart):
        self.r = realpart
        self.i = implpart

class Dog:
    def __init__(self, name):
        self.name = name
        self.tricks = []

    def add_trick(self, trick):
        self.tricks.append(trick)

#Inheritance
&amp;quot;&amp;quot;&amp;quot;
inheritance class structure
class DerivedClass(BaseClass):
&amp;quot;&amp;quot;&amp;quot;

class Animal(object):
    def run(self):
        print &amp;quot;Animal is running...&amp;quot;
    def __len__(self):
        return 1000


class Cat(Animal):
    def run(self):
        print &amp;quot;Cat is running....&amp;quot;

    def eat(self):
        print &amp;quot;Cat eat rat....&amp;quot;

class Horse(Animal):
    def run(self):
        print &amp;quot;Horse is running....&amp;quot;
    def eat(self):
        print &amp;quot;Horse is eat glass....&amp;quot;

#:polymorphic testing. Put the father type in testing function as var.
def run_twice(animal):
    animal.run()
    animal.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;testing_class.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/19/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;


import unittest
from unittest import TestCase

from learnpy.learning_class import My_Class
from learnpy.learning_class import Complex
from learnpy.learning_class import Dog
from learnpy.learning_class import Animal
from learnpy.learning_class import Cat
from learnpy.learning_class import Horse
from learnpy.learning_class import run_twice

class Test_Class(TestCase):

    def test_init(self):
        x = My_Class()
        x = [1,2,3,4,5,6]
        print x

        y = Complex(5,6)
        print y.r, y.i


    def test_dog(self):
        cla = Dog(&amp;quot;cla&amp;quot;)
        cla.add_trick(&amp;quot;trick_1&amp;quot;)
        cla.add_trick(&amp;quot;trick_2&amp;quot;)

        print cla.name
        print cla.tricks


    def test_inheritance(self):
        ins_cat = Cat();
        ins_horse = Horse();

        ins_cat.run()
        ins_horse.run()

        ins_cat.eat()
        ins_horse.eat()


    def test_instance(self):
        test_a = list()
        test_b = Cat()
        test_c = Horse()
        test_d = Animal()

        if isinstance(test_a, list):
            print &amp;quot;test_a is the list type!&amp;quot;
        else:
            print &amp;quot;test_a is not the list type!&amp;quot;

        if isinstance(test_b, Cat):
            print &amp;quot;test_is the Cat type!&amp;quot;
        else:
            print &amp;quot;test_b is not the Cat type!&amp;quot;

        if isinstance(test_c, Horse):
            print &amp;quot;test_c is the Horse type!&amp;quot;
        else:
            print &amp;quot;test_c is not the Horse type!&amp;quot;

        if isinstance(test_d, Animal):
            print &amp;quot;test_d the Animal type!&amp;quot;
        else:
            print &amp;quot;test_d is not the Animal type!&amp;quot;

        if isinstance(test_d, Horse):
            print &amp;quot;test_d is the Horse&amp;quot;
        else:
            print &amp;quot;test_d is not the Horse type!&amp;quot;

        #Testing the polymorphic
        run_twice(test_b)
        run_twice(test_c)
        run_twice(test_d)

        #Like __**__() function just have sepcial use in the python
        #We can mock __len__() function
        #Let the sys know our class have length
        print  test_d.__len__()
        print  test_c.__len__()
        print  test_b.__len__()

        #dir()
        #This function will show the all methods and attributes 
        print dir(test_d)   

if __name__ == &amp;#39;__main__&amp;#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Five</title>
        <link>http://eledata.github.io/2014/09/20/Learn-Python-Exercise-Five.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/20/Learn-Python-Exercise-Five.html</guid>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Python functions&lt;/p&gt;

&lt;p&gt;There are many python&amp;#39;s function types. Such as if-else, if-elif-else, for in, while, &lt;/p&gt;

&lt;p&gt;lambda etc. &lt;/p&gt;

&lt;p&gt;learning&lt;em&gt;python&lt;/em&gt;func.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/19/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
if else structure
&amp;quot;&amp;quot;&amp;quot;
import statsout


def my_abs(x):
    if x &amp;gt;= 0:
        return x
    else:
        return -x

&amp;quot;&amp;quot;&amp;quot;
while structure
&amp;quot;&amp;quot;&amp;quot;
def my_power(x,y):
    tmp = 1
    while y &amp;gt; 0:
        y = y - 1
        tmp = tmp * x
    return tmp

def my_power_5(x, y = 5):
    tmp = 1
    while y &amp;gt; 0:
        y = y - 1
        tmp = tmp * x
    return tmp

&amp;quot;&amp;quot;&amp;quot;
For loop structure
&amp;quot;&amp;quot;&amp;quot;
def my_for_in():
    temp = 0
    for i in range(2,10):
        for j in range(1,i):
            temp = temp + i + j
    return temp


&amp;quot;&amp;quot;&amp;quot;
Internal function
range(), len()
&amp;quot;&amp;quot;&amp;quot;

def my_range_len():
    a = [&amp;#39;Mary&amp;#39;, &amp;#39;had&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;little&amp;#39;, &amp;#39;lamb&amp;#39;]
    for i in range(len(a)):
        print i, a[i]


&amp;quot;&amp;quot;&amp;quot;
function doc
&amp;quot;&amp;quot;&amp;quot;
def func_doc():
    &amp;quot;&amp;quot;&amp;quot;
    test the function doc!
    print test_func_doc.__doc__
    &amp;quot;&amp;quot;&amp;quot;
    pass

&amp;quot;&amp;quot;&amp;quot;
lambda
example: lambda var: logc 
&amp;quot;&amp;quot;&amp;quot;
def lambda_func():
    print &amp;quot;Show how lamanda work:&amp;quot;, (lambda x:x*3)(4)

&amp;#39;&amp;#39;&amp;#39;
fib function
&amp;#39;&amp;#39;&amp;#39;
def fib(n):
    a, b = 0, 1
    while a &amp;lt; n:
        print a
        a, b = b, a+b

def fib_list(n):
    a, b = 0, 1
    result = []
    while a &amp;lt; n:
        result.append(a)
        a, b = b, a+b
    &amp;#39;&amp;#39;&amp;#39;
    return a list object
    &amp;#39;&amp;#39;&amp;#39;
    return result 

&amp;#39;&amp;#39;&amp;#39;
input argument contain list and xingcan
&amp;#39;&amp;#39;&amp;#39;
def f(a, L=[]):
    L.append(a)
    return L


#*argument means list
#**keywords means dict
def cheeseshop(kind, *arguments, **keywords):
    print &amp;quot;-- Do you have any&amp;quot;, kind, &amp;quot;?&amp;quot;
    print &amp;quot;-- I&amp;#39;m sorry, we&amp;#39;re all out of&amp;quot;, kind
    #list, for loop to catch the data
    for arg in arguments:
        print arg
    print &amp;quot;-&amp;quot; * 40

    #dict, for loop to catch the data
    keys = sorted(keywords.keys())
    for kw in keys:
        print kw, &amp;quot;:&amp;quot;, keywords[kw]

#getattri
def test_getattri(self):
    li = [&amp;#39;test1&amp;#39;,&amp;#39;test2&amp;#39;]
    getattr(li, &amp;quot;append&amp;quot;)(&amp;quot;test3&amp;quot;)
    print li

def output(data, format=&amp;quot;text&amp;quot;):
    output_function = getattr(statsout, &amp;quot;output_%s&amp;quot; % format, statsout.statsout_text)
    return output_function(data)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;testing_func.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/19/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

import unittest
from unittest import TestCase

from learnpy.learning_func import my_abs
import learnpy.learning_func
from learnpy.learning_func import lambda_func
from learnpy.learning_func import cheeseshop

class Test_learn_func(TestCase):

    def test_abs(self):
        self.assertEqual(5,my_abs(-5))

    def test_power(self):
        self.assertEqual(100, learnpy.learning_func.my_power(10,2))
        self.assertEqual(32,  learnpy.learning_func.my_power_5(2))

    def test_for_in(self):
        self.assertEqual(360,  learnpy.learning_func.my_for_in())

    def test_range_len(self):
        learnpy.learning_func.my_range_len()

    def test_func_doc(self):
        print learnpy.learning_func.func_doc().__doc__

    def test_lambda(self):
        lambda_func()

    def test_cheeseshop(self):
        cheeseshop(&amp;#39;Limburger&amp;#39;, &amp;#39;It\&amp;#39; very runny, sir&amp;#39;,
                   &amp;quot;It&amp;#39;s really very, VERY runny, sir.&amp;quot;,            
                   shopkeeper=&amp;#39;Michael Palin&amp;#39;,
                   client=&amp;quot;John Cleese&amp;quot;,
                   sketch=&amp;quot;Cheese Shop Sketch&amp;quot;)


if __name__ == &amp;#39;__main__&amp;#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Linux 3：文件与目录管理</title>
        <link>http://eledata.github.io/2014/09/19/Linux3.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/19/Linux3.html</guid>
        <pubDate>Fri, 19 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;目录的相关操作&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;.         # 代表此层目录
..        # 代表上一层目录
-         # 代表前一个工作目录
~         # 代表『目前使用者身份』所在的家目录
~account  # 代表 account 这个使用者的家目录(account是个帐号名称)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;在所有目录底下都会存在的两个目录，分别是&lt;code&gt;.&lt;/code&gt;与&lt;code&gt;..&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根目录的上一层&lt;code&gt;(..)&lt;/code&gt;与根目录自己&lt;code&gt;(.)&lt;/code&gt;是同一个目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;几个常见的处理目录的命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;cd：变换目录，cd是Change Directory的缩写&lt;/li&gt;
&lt;li&gt;pwd：显示目前的目录，pwd是Print Working Directory的缩写&lt;/li&gt;
&lt;li&gt;mkdir：创建一个新的目录&lt;/li&gt;
&lt;li&gt;rmdir：删除一个空的目录&lt;/li&gt;
&lt;li&gt;mv：移动文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pwd -P                   # -P：代表显示正确的完整路径，而不是连接路径
mkdir -m xxx             # -m：直接配置文件的权限
mkdir -p test1/test2     # -p：直接将所需要的目录(包含上一级目录)递回创建起来！
PATH=&amp;quot;$PATH&amp;quot;:/root       # 将/root路径加入PATH环境变量中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件与目录管理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件与目录的检视： ls&lt;/li&gt;
&lt;li&gt;复制、删除与移动： cp, rm, mv&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cp -a        # 将文件的所有特性都一起复制过来
cp -p        # 连同文件的属性一起复制过去，而非使用默认属性(备份常用)
cp -r        # 可以复制目录，但是，文件与目录的权限可能会被改变
rm -i        # 互动模式，在删除前会询问使用者是否动作
rm -r        # 连目录下的东西一起删掉，并且不会询问，慎用
mv -f        # force强制移动，如果目标文件已经存在，不会询问而直接覆盖
mv -i        # 若目标文件 (destination) 已经存在时，就会询问是否覆盖
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件内容查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;直接检视文件内容： cat, tac, nl （常用）&lt;/li&gt;
&lt;li&gt;可翻页检视： more, less （常用）&lt;/li&gt;
&lt;li&gt;数据撷取： head, tail&lt;/li&gt;
&lt;li&gt;非纯文字档： od&lt;/li&gt;
&lt;li&gt;修改文件时间与建置新档： touch&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cat [-AbEnTv] filename # 由第一行开始显示文件内容。-b列出非空白行行号；-n列出所有行号。
tac                    # 从最后一行开始显示文件内容，tac就是cat倒着写！
nl                     # 显示文件内容，顺便输出行号
more                   # 一页一页地显示文件内容
less                   # 与more类似，但可以往前翻页
head [-n number]       # 只看文件头几行，默认是10行，number是自定义行数
tail                   # 只看文件尾几行，文件很大的时候常用
od                     # 以二进制方式读取文件内容
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件与目录的默认权限与隐藏权限&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件默认权限：umask&lt;/li&gt;
&lt;li&gt;文件隐藏属性： chattr, lsattr&lt;/li&gt;
&lt;li&gt;文件特殊权限：SUID, SGID, SBIT, 权限配置&lt;/li&gt;
&lt;li&gt;观察文件类型：file&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;umask           # 后三位数是被拿走的权限分数，比如0022，u没有被拿走权限，g和o被拿走了w权限
umask -S        # 以符号类型来显示权限
umask number    # 配置自己需要的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在默认的情况中，root的umask会拿掉比较多的属性，root的umask默认是&lt;code&gt;022&lt;/code&gt;， 这是基於安全的考量啦～至於一般身份使用者，通常他们的 umask 为&lt;code&gt;002&lt;/code&gt; ，亦即保留同群组的写入权力。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;特殊权限&lt;code&gt;s&lt;/code&gt;和&lt;code&gt;t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Set UID，简称SUID，当s标志在文件拥有者的x项目为SUID，对目录无效&lt;/li&gt;
&lt;li&gt;Set GID，简称SGID，当s标志在群组的x项目为SGID，对目录有效&lt;/li&gt;
&lt;li&gt;Sticky Bit, 简称SBIT，目前只针对目录有效，对於文件已经没有效果了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置SUID,SGID,SBIT权限&lt;/h3&gt;

&lt;p&gt;在原有的权限数字前面加上需要配置的权限数字。
比如&lt;code&gt;755&lt;/code&gt;-&amp;gt;&lt;code&gt;4755&lt;/code&gt; ，就意味着&lt;code&gt;-rwxr-xr-x&lt;/code&gt;变为了&lt;code&gt;-rwsr-xr-x&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;4 为 SUID&lt;/li&gt;
&lt;li&gt;2 为 SGID&lt;/li&gt;
&lt;li&gt;1 为 SBIT&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;chmod 4755 filename
chmod u=rwxs,go=x test; ls -l test      # 配置权限为-rws--x--x的模样
chmod g+s,o+t test; ls -l test          # 配置权限为-rws--s--t，即加入SGID,SBIT权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;命令与文件的搜寻&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;命令档名的搜寻：which&lt;/li&gt;
&lt;li&gt;文件档名的搜寻：whereis, locate, find&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;权限与命令的关系&lt;/h3&gt;

&lt;h4&gt;一、让使用者能进入某目录成为『可工作目录』的基本权限为何：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可使用的命令：例如 cd 等变换工作目录的命令；&lt;/li&gt;
&lt;li&gt;目录所需权限：使用者对这个目录至少需要具有 x 的权限&lt;/li&gt;
&lt;li&gt;额外需求：如果使用者想要在这个目录内利用 ls 查阅档名，则使用者对此目录还需要 r 的权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;二、使用者在某个目录内读取一个文件的基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可使用的命令：例如本章谈到的 cat, more, less等等&lt;/li&gt;
&lt;li&gt;目录所需权限：使用者对这个目录至少需要具有 x 权限；&lt;/li&gt;
&lt;li&gt;文件所需权限：使用者对文件至少需要具有 r 的权限才行！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;三、让使用者可以修改一个文件的基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可使用的命令：例如 nano 或未来要介绍的 vi 编辑器等；&lt;/li&gt;
&lt;li&gt;目录所需权限：使用者在该文件所在的目录至少要有 x 权限；&lt;/li&gt;
&lt;li&gt;文件所需权限：使用者对该文件至少要有 r, w 权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;四、让一个使用者可以创建一个文件的基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;五、让使用者进入某目录并运行该目录下的某个命令之基本权限为何？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;目录所需权限：使用者在该目录至少要有 x 的权限；&lt;/li&gt;
&lt;li&gt;文件所需权限：使用者在该文件至少需要有 x 的权限&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Three</title>
        <link>http://eledata.github.io/2014/09/19/Learn-Python-Exercise-Three.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/19/Learn-Python-Exercise-Three.html</guid>
        <pubDate>Fri, 19 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Built-in Functions
The Python interpreter has a number of functions built into it that are always available. They are listed here in alphabetical order.&lt;/p&gt;

&lt;p&gt;Built-in Functions&lt;br&gt;
abs() divmod() input() open() staticmethod() 
all() enumerate() int() ord() str() 
any() eval() isinstance() pow() sum() 
basestring() execfile() issubclass() print() super() 
bin() file() iter() property() tuple() 
bool() filter() len() range() type() 
bytearray() float() list() raw&lt;em&gt;input() unichr() 
callable() format() locals() reduce() unicode() 
chr() frozenset() long() reload() vars() 
classmethod() getattr() map() repr() xrange() 
cmp() globals() max() reversed() zip() 
compile() hasattr() memoryview() round() _&lt;/em&gt;import__() 
complex() hash() min() set() apply() 
delattr() help() next() setattr() buffer() 
dict() hex() object() slice() coerce() 
dir() id() oct() sorted() intern() &lt;/p&gt;

&lt;p&gt;abs(x) 
Return the absolute value of a number. The argument may be a plain or long integer or a floating point number. If the argument is a complex number, its magnitude is returned.&lt;/p&gt;

&lt;p&gt;all(iterable) 
Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to:&lt;/p&gt;

&lt;p&gt;def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
New in version 2.5.&lt;/p&gt;

&lt;p&gt;any(iterable) 
Return True if any element of the iterable is true. If the iterable is empty, return False. Equivalent to:&lt;/p&gt;

&lt;p&gt;def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
New in version 2.5.&lt;/p&gt;

&lt;p&gt;basestring() 
This abstract type is the superclass for str and unicode. It cannot be called or instantiated, but it can be used to test whether an object is an instance of str or unicode. isinstance(obj, basestring) is equivalent to isinstance(obj, (str, unicode)).&lt;/p&gt;

&lt;p&gt;New in version 2.3.&lt;/p&gt;

&lt;p&gt;bin(x) 
Convert an integer number to a binary string. The result is a valid Python expression. If x is not a Python int object, it has to define an &lt;strong&gt;index&lt;/strong&gt;() method that returns an integer.&lt;/p&gt;

&lt;p&gt;New in version 2.6.&lt;/p&gt;

&lt;p&gt;bool([x]) 
Convert a value to a Boolean, using the standard truth testing procedure. If x is false or omitted, this returns False; otherwise it returns True. bool is also a class, which is a subclass of int. Class bool cannot be subclassed further. Its only instances are False and True.&lt;/p&gt;

&lt;p&gt;New in version 2.2.1.&lt;/p&gt;

&lt;p&gt;Changed in version 2.3: If no argument is given, this function returns False.&lt;/p&gt;

&lt;p&gt;bytearray([source[, encoding[, errors]]]) 
Return a new array of bytes. The bytearray type is a mutable sequence of integers in the range 0 &amp;lt;= x &amp;lt; 256. It has most of the usual methods of mutable sequences, described in Mutable Sequence Types, as well as most methods that the str type has, see String Methods.&lt;/p&gt;

&lt;p&gt;The optional source parameter can be used to initialize the array in a few different ways:&lt;/p&gt;

&lt;p&gt;If it is a string, you must also give the encoding (and optionally, errors) parameters; bytearray() then converts the string to bytes using str.encode(). 
If it is an integer, the array will have that size and will be initialized with null bytes. 
If it is an object conforming to the buffer interface, a read-only buffer of the object will be used to initialize the bytes array. 
If it is an iterable, it must be an iterable of integers in the range 0 &amp;lt;= x &amp;lt; 256, which are used as the initial contents of the array. 
Without an argument, an array of size 0 is created.&lt;/p&gt;

&lt;p&gt;New in version 2.6.&lt;/p&gt;

&lt;p&gt;callable(object) 
Return True if the object argument appears callable, False if not. If this returns true, it is still possible that a call fails, but if it is false, calling object will never succeed. Note that classes are callable (calling a class returns a new instance); class instances are callable if they have a &lt;strong&gt;call&lt;/strong&gt;() method.&lt;/p&gt;

&lt;p&gt;chr(i) 
Return a string of one character whose ASCII code is the integer i. For example, chr(97) returns the string &amp;#39;a&amp;#39;. This is the inverse of ord(). The argument must be in the range [0..255], inclusive; ValueError will be raised if i is outside that range. See also unichr().&lt;/p&gt;

&lt;p&gt;classmethod(function) 
Return a class method for function.&lt;/p&gt;

&lt;p&gt;A class method receives the class as implicit first argument, just like an instance method receives the instance. To declare a class method, use this idiom:&lt;/p&gt;

&lt;p&gt;class C(object):
    @classmethod
    def f(cls, arg1, arg2, ...):
        ...
The @classmethod form is a function decorator – see the description of function definitions in Function definitions for details.&lt;/p&gt;

&lt;p&gt;It can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class. If a class method is called for a derived class, the derived class object is passed as the implied first argument.&lt;/p&gt;

&lt;p&gt;Class methods are different than C++ or Java static methods. If you want those, see staticmethod() in this section.&lt;/p&gt;

&lt;p&gt;For more information on class methods, consult the documentation on the standard type hierarchy in The standard type hierarchy.&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;Changed in version 2.4: Function decorator syntax added.&lt;/p&gt;

&lt;p&gt;cmp(x, y) 
Compare the two objects x and y and return an integer according to the outcome. The return value is negative if x &amp;lt; y, zero if x == y and strictly positive if x &amp;gt; y.&lt;/p&gt;

&lt;p&gt;compile(source, filename, mode[, flags[, dont_inherit]]) 
Compile the source into a code or AST object. Code objects can be executed by an exec statement or evaluated by a call to eval(). source can either be a Unicode string, a Latin-1 encoded string or an AST object. Refer to the ast module documentation for information on how to work with AST objects.&lt;/p&gt;

&lt;p&gt;The filename argument should give the file from which the code was read; pass some recognizable value if it wasn’t read from a file (&amp;#39;&lt;string&gt;&amp;#39; is commonly used).&lt;/p&gt;

&lt;p&gt;The mode argument specifies what kind of code must be compiled; it can be &amp;#39;exec&amp;#39; if source consists of a sequence of statements, &amp;#39;eval&amp;#39; if it consists of a single expression, or &amp;#39;single&amp;#39; if it consists of a single interactive statement (in the latter case, expression statements that evaluate to something other than None will be printed).&lt;/p&gt;

&lt;p&gt;The optional arguments flags and dont&lt;em&gt;inherit control which future statements (see PEP 236) affect the compilation of source. If neither is present (or both are zero) the code is compiled with those future statements that are in effect in the code that is calling compile. If the flags argument is given and dont&lt;/em&gt;inherit is not (or is zero) then the future statements specified by the flags argument are used in addition to those that would be used anyway. If dont_inherit is a non-zero integer then the flags argument is it – the future statements in effect around the call to compile are ignored.&lt;/p&gt;

&lt;p&gt;Future statements are specified by bits which can be bitwise ORed together to specify multiple statements. The bitfield required to specify a given feature can be found as the compiler&lt;em&gt;flag attribute on the _Feature instance in the _&lt;/em&gt;future__ module.&lt;/p&gt;

&lt;p&gt;This function raises SyntaxError if the compiled source is invalid, and TypeError if the source contains null bytes.&lt;/p&gt;

&lt;p&gt;Note
When compiling a string with multi-line code in &amp;#39;single&amp;#39; or &amp;#39;eval&amp;#39; mode, input must be terminated by at least one newline character. This is to facilitate detection of incomplete and complete statements in the code module.&lt;/p&gt;

&lt;p&gt;Changed in version 2.3: The flags and dont_inherit arguments were added.&lt;/p&gt;

&lt;p&gt;Changed in version 2.6: Support for compiling AST objects.&lt;/p&gt;

&lt;p&gt;Changed in version 2.7: Allowed use of Windows and Mac newlines. Also input in &amp;#39;exec&amp;#39; mode does not have to end in a newline anymore.&lt;/p&gt;

&lt;p&gt;complex([real[, imag]]) 
Create a complex number with the value real + imag*j or convert a string or number to a complex number. If the first parameter is a string, it will be interpreted as a complex number and the function must be called without a second parameter. The second parameter can never be a string. Each argument may be any numeric type (including complex). If imag is omitted, it defaults to zero and the function serves as a numeric conversion function like int(), long() and float(). If both arguments are omitted, returns 0j.&lt;/p&gt;

&lt;p&gt;Note
When converting from a string, the string must not contain whitespace around the central + or - operator. For example, complex(&amp;#39;1+2j&amp;#39;) is fine, but complex(&amp;#39;1 + 2j&amp;#39;) raises ValueError.&lt;/p&gt;

&lt;p&gt;The complex type is described in Numeric Types — int, float, long, complex.&lt;/p&gt;

&lt;p&gt;delattr(object, name) 
This is a relative of setattr(). The arguments are an object and a string. The string must be the name of one of the object’s attributes. The function deletes the named attribute, provided the object allows it. For example, delattr(x, &amp;#39;foobar&amp;#39;) is equivalent to del x.foobar.&lt;/p&gt;

&lt;p&gt;dict(*&lt;em&gt;kwarg) 
dict(mapping, *&lt;/em&gt;kwarg) 
dict(iterable, **kwarg) 
Create a new dictionary. The dict object is the dictionary class. See dict and Mapping Types — dict for documentation about this class.&lt;/p&gt;

&lt;p&gt;For other containers see the built-in list, set, and tuple classes, as well as the collections module.&lt;/p&gt;

&lt;p&gt;dir([object]) 
Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.&lt;/p&gt;

&lt;p&gt;If the object has a method named &lt;strong&gt;dir&lt;/strong&gt;(), this method will be called and must return the list of attributes. This allows objects that implement a custom &lt;strong&gt;getattr&lt;/strong&gt;() or &lt;strong&gt;getattribute&lt;/strong&gt;() function to customize the way dir() reports their attributes.&lt;/p&gt;

&lt;p&gt;If the object does not provide &lt;strong&gt;dir&lt;/strong&gt;(), the function tries its best to gather information from the object’s &lt;strong&gt;dict&lt;/strong&gt; attribute, if defined, and from its type object. The resulting list is not necessarily complete, and may be inaccurate when the object has a custom &lt;strong&gt;getattr&lt;/strong&gt;().&lt;/p&gt;

&lt;p&gt;The default dir() mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information:&lt;/p&gt;

&lt;p&gt;If the object is a module object, the list contains the names of the module’s attributes. 
If the object is a type or class object, the list contains the names of its attributes, and recursively of the attributes of its bases. 
Otherwise, the list contains the object’s attributes’ names, the names of its class’s attributes, and recursively of the attributes of its class’s base classes. 
The resulting list is sorted alphabetically. For example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;import struct
dir()   # show the names in the module namespace
[&amp;#39;&lt;strong&gt;builtins&lt;/strong&gt;&amp;#39;, &amp;#39;&lt;strong&gt;doc&lt;/strong&gt;&amp;#39;, &amp;#39;&lt;strong&gt;name&lt;/strong&gt;&amp;#39;, &amp;#39;struct&amp;#39;]
dir(struct)   # show the names in the struct module
[&amp;#39;Struct&amp;#39;, &amp;#39;&lt;strong&gt;builtins&lt;/strong&gt;&amp;#39;, &amp;#39;&lt;strong&gt;doc&lt;/strong&gt;&amp;#39;, &amp;#39;&lt;strong&gt;file&lt;/strong&gt;&amp;#39;, &amp;#39;&lt;strong&gt;name&lt;/strong&gt;&amp;#39;,
 &amp;#39;&lt;strong&gt;package&lt;/strong&gt;&amp;#39;, &amp;#39;&lt;em&gt;clearcache&amp;#39;, &amp;#39;calcsize&amp;#39;, &amp;#39;error&amp;#39;, &amp;#39;pack&amp;#39;, &amp;#39;pack&lt;/em&gt;into&amp;#39;,
 &amp;#39;unpack&amp;#39;, &amp;#39;unpack&lt;em&gt;from&amp;#39;]
class Shape(object):
        def _&lt;/em&gt;dir__(self):
            return [&amp;#39;area&amp;#39;, &amp;#39;perimeter&amp;#39;, &amp;#39;location&amp;#39;]
s = Shape()
dir(s)
[&amp;#39;area&amp;#39;, &amp;#39;perimeter&amp;#39;, &amp;#39;location&amp;#39;]
Note
Because dir() is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, metaclass attributes are not in the result list when the argument is a class.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;divmod(a, b) 
Take two (non complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using long division. With mixed operand types, the rules for binary arithmetic operators apply. For plain and long integers, the result is the same as (a // b, a % b). For floating point numbers the result is (q, a % b), where q is usually math.floor(a / b) but may be 1 less than that. In any case q * b + a % b is very close to a, if a % b is non-zero it has the same sign as b, and 0 &amp;lt;= abs(a % b) &amp;lt; abs(b).&lt;/p&gt;

&lt;p&gt;Changed in version 2.3: Using divmod() with complex numbers is deprecated.&lt;/p&gt;

&lt;p&gt;enumerate(sequence, start=0) 
Return an enumerate object. sequence must be a sequence, an iterator, or some other object which supports iteration. The next() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over sequence:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;seasons = [&amp;#39;Spring&amp;#39;, &amp;#39;Summer&amp;#39;, &amp;#39;Fall&amp;#39;, &amp;#39;Winter&amp;#39;]
list(enumerate(seasons))
[(0, &amp;#39;Spring&amp;#39;), (1, &amp;#39;Summer&amp;#39;), (2, &amp;#39;Fall&amp;#39;), (3, &amp;#39;Winter&amp;#39;)]
list(enumerate(seasons, start=1))
[(1, &amp;#39;Spring&amp;#39;), (2, &amp;#39;Summer&amp;#39;), (3, &amp;#39;Fall&amp;#39;), (4, &amp;#39;Winter&amp;#39;)]
Equivalent to:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
New in version 2.3.&lt;/p&gt;

&lt;p&gt;Changed in version 2.6: The start parameter was added.&lt;/p&gt;

&lt;p&gt;eval(expression[, globals[, locals]]) 
The arguments are a Unicode or Latin-1 encoded string and optional globals and locals. If provided, globals must be a dictionary. If provided, locals can be any mapping object.&lt;/p&gt;

&lt;p&gt;Changed in version 2.4: formerly locals was required to be a dictionary.&lt;/p&gt;

&lt;p&gt;The expression argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the globals and locals dictionaries as global and local namespace. If the globals dictionary is present and lacks ‘&lt;strong&gt;builtins&lt;/strong&gt;’, the current globals are copied into globals before expression is parsed. This means that expression normally has full access to the standard &lt;strong&gt;builtin&lt;/strong&gt; module and restricted environments are propagated. If the locals dictionary is omitted it defaults to the globals dictionary. If both dictionaries are omitted, the expression is executed in the environment where eval() is called. The return value is the result of the evaluated expression. Syntax errors are reported as exceptions. Example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;x = 1
print eval(&amp;#39;x+1&amp;#39;)
2
This function can also be used to execute arbitrary code objects (such as those created by compile()). In this case pass a code object instead of a string. If the code object has been compiled with &amp;#39;exec&amp;#39; as the mode argument, eval()‘s return value will be None.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hints: dynamic execution of statements is supported by the exec statement. Execution of statements from a file is supported by the execfile() function. The globals() and locals() functions returns the current global and local dictionary, respectively, which may be useful to pass around for use by eval() or execfile().&lt;/p&gt;

&lt;p&gt;See ast.literal_eval() for a function that can safely evaluate strings with expressions containing only literals.&lt;/p&gt;

&lt;p&gt;execfile(filename[, globals[, locals]]) 
This function is similar to the exec statement, but parses a file instead of a string. It is different from the import statement in that it does not use the module administration — it reads the file unconditionally and does not create a new module. [1]&lt;/p&gt;

&lt;p&gt;The arguments are a file name and two optional dictionaries. The file is parsed and evaluated as a sequence of Python statements (similarly to a module) using the globals and locals dictionaries as global and local namespace. If provided, locals can be any mapping object. Remember that at module level, globals and locals are the same dictionary. If two separate objects are passed as globals and locals, the code will be executed as if it were embedded in a class definition.&lt;/p&gt;

&lt;p&gt;Changed in version 2.4: formerly locals was required to be a dictionary.&lt;/p&gt;

&lt;p&gt;If the locals dictionary is omitted it defaults to the globals dictionary. If both dictionaries are omitted, the expression is executed in the environment where execfile() is called. The return value is None.&lt;/p&gt;

&lt;p&gt;Note
The default locals act as described for function locals() below: modifications to the default locals dictionary should not be attempted. Pass an explicit locals dictionary if you need to see effects of the code on locals after function execfile() returns. execfile() cannot be used reliably to modify a function’s locals.&lt;/p&gt;

&lt;p&gt;file(name[, mode[, buffering]]) 
Constructor function for the file type, described further in section File Objects. The constructor’s arguments are the same as those of the open() built-in function described below.&lt;/p&gt;

&lt;p&gt;When opening a file, it’s preferable to use open() instead of invoking this constructor directly. file is more suited to type testing (for example, writing isinstance(f, file)).&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;filter(function, iterable) 
Construct a list from those elements of iterable for which function returns true. iterable may be either a sequence, a container which supports iteration, or an iterator. If iterable is a string or a tuple, the result also has that type; otherwise it is always a list. If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed.&lt;/p&gt;

&lt;p&gt;Note that filter(function, iterable) is equivalent to [item for item in iterable if function(item)] if function is not None and [item for item in iterable if item] if function is None.&lt;/p&gt;

&lt;p&gt;See itertools.ifilter() and itertools.ifilterfalse() for iterator versions of this function, including a variation that filters for elements where the function returns false.&lt;/p&gt;

&lt;p&gt;float([x]) 
Convert a string or a number to floating point. If the argument is a string, it must contain a possibly signed decimal or floating point number, possibly embedded in whitespace. The argument may also be [+|-]nan or [+|-]inf. Otherwise, the argument may be a plain or long integer or a floating point number, and a floating point number with the same value (within Python’s floating point precision) is returned. If no argument is given, returns 0.0.&lt;/p&gt;

&lt;p&gt;Note
When passing in a string, values for NaN and Infinity may be returned, depending on the underlying C library. Float accepts the strings nan, inf and -inf for NaN and positive or negative infinity. The case and a leading + are ignored as well as a leading - is ignored for NaN. Float always represents NaN and infinity as nan, inf or -inf.&lt;/p&gt;

&lt;p&gt;The float type is described in Numeric Types — int, float, long, complex.&lt;/p&gt;

&lt;p&gt;format(value[, format&lt;em&gt;spec]) 
Convert a value to a “formatted” representation, as controlled by format&lt;/em&gt;spec. The interpretation of format_spec will depend on the type of the value argument, however there is a standard formatting syntax that is used by most built-in types: Format Specification Mini-Language.&lt;/p&gt;

&lt;p&gt;Note
format(value, format&lt;em&gt;spec) merely calls value.&lt;/em&gt;&lt;em&gt;format&lt;/em&gt;&lt;em&gt;(format&lt;/em&gt;spec).&lt;/p&gt;

&lt;p&gt;New in version 2.6.&lt;/p&gt;

&lt;p&gt;frozenset([iterable]) 
Return a new frozenset object, optionally with elements taken from iterable. frozenset is a built-in class. See frozenset and Set Types — set, frozenset for documentation about this class.&lt;/p&gt;

&lt;p&gt;For other containers see the built-in set, list, tuple, and dict classes, as well as the collections module.&lt;/p&gt;

&lt;p&gt;New in version 2.4.&lt;/p&gt;

&lt;p&gt;getattr(object, name[, default]) 
Return the value of the named attribute of object. name must be a string. If the string is the name of one of the object’s attributes, the result is the value of that attribute. For example, getattr(x, &amp;#39;foobar&amp;#39;) is equivalent to x.foobar. If the named attribute does not exist, default is returned if provided, otherwise AttributeError is raised.&lt;/p&gt;

&lt;p&gt;globals() 
Return a dictionary representing the current global symbol table. This is always the dictionary of the current module (inside a function or method, this is the module where it is defined, not the module from which it is called).&lt;/p&gt;

&lt;p&gt;hasattr(object, name) 
The arguments are an object and a string. The result is True if the string is the name of one of the object’s attributes, False if not. (This is implemented by calling getattr(object, name) and seeing whether it raises an exception or not.)&lt;/p&gt;

&lt;p&gt;hash(object) 
Return the hash value of the object (if it has one). Hash values are integers. They are used to quickly compare dictionary keys during a dictionary lookup. Numeric values that compare equal have the same hash value (even if they are of different types, as is the case for 1 and 1.0).&lt;/p&gt;

&lt;p&gt;help([object]) 
Invoke the built-in help system. (This function is intended for interactive use.) If no argument is given, the interactive help system starts on the interpreter console. If the argument is a string, then the string is looked up as the name of a module, function, class, method, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is generated.&lt;/p&gt;

&lt;p&gt;This function is added to the built-in namespace by the site module.&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;hex(x) 
Convert an integer number (of any size) to a lowercase hexadecimal string prefixed with “0x”, for example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;hex(255)
&amp;#39;0xff&amp;#39;
hex(-42)
&amp;#39;-0x2a&amp;#39;
hex(1L)
&amp;#39;0x1L&amp;#39;
If x is not a Python int or long object, it has to define an &lt;strong&gt;index&lt;/strong&gt;() method that returns an integer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;See also int() for converting a hexadecimal string to an integer using a base of 16.&lt;/p&gt;

&lt;p&gt;Note
To obtain a hexadecimal string representation for a float, use the float.hex() method.&lt;/p&gt;

&lt;p&gt;Changed in version 2.4: Formerly only returned an unsigned literal.&lt;/p&gt;

&lt;p&gt;id(object) 
Return the “identity” of an object. This is an integer (or long integer) which is guaranteed to be unique and constant for this object during its lifetime. Two objects with non-overlapping lifetimes may have the same id() value.&lt;/p&gt;

&lt;p&gt;CPython implementation detail: This is the address of the object in memory.&lt;/p&gt;

&lt;p&gt;input([prompt]) 
Equivalent to eval(raw_input(prompt)).&lt;/p&gt;

&lt;p&gt;This function does not catch user errors. If the input is not syntactically valid, a SyntaxError will be raised. Other exceptions may be raised if there is an error during evaluation.&lt;/p&gt;

&lt;p&gt;If the readline module was loaded, then input() will use it to provide elaborate line editing and history features.&lt;/p&gt;

&lt;p&gt;Consider using the raw_input() function for general input from users.&lt;/p&gt;

&lt;p&gt;int(x=0) 
int(x, base=10) 
Convert a number or string x to an integer, or return 0 if no arguments are given. If x is a number, it can be a plain integer, a long integer, or a floating point number. If x is floating point, the conversion truncates towards zero. If the argument is outside the integer range, the function returns a long object instead.&lt;/p&gt;

&lt;p&gt;If x is not a number or if base is given, then x must be a string or Unicode object representing an integer literal in radix base. Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z) having values 10 to 35. The default base is 10. The allowed values are 0 and 2-36. Base-2, -8, and -16 literals can be optionally prefixed with 0b/0B, 0o/0O/0, or 0x/0X, as with integer literals in code. Base 0 means to interpret the string exactly as an integer literal, so that the actual base is 2, 8, 10, or 16.&lt;/p&gt;

&lt;p&gt;The integer type is described in Numeric Types — int, float, long, complex.&lt;/p&gt;

&lt;p&gt;isinstance(object, classinfo) 
Return true if the object argument is an instance of the classinfo argument, or of a (direct, indirect or virtual) subclass thereof. Also return true if classinfo is a type object (new-style class) and object is an object of that type or of a (direct, indirect or virtual) subclass thereof. If object is not a class instance or an object of the given type, the function always returns false. If classinfo is neither a class object nor a type object, it may be a tuple of class or type objects, or may recursively contain other such tuples (other sequence types are not accepted). If classinfo is not a class, type, or tuple of classes, types, and such tuples, a TypeError exception is raised.&lt;/p&gt;

&lt;p&gt;Changed in version 2.2: Support for a tuple of type information was added.&lt;/p&gt;

&lt;p&gt;issubclass(class, classinfo) 
Return true if class is a subclass (direct, indirect or virtual) of classinfo. A class is considered a subclass of itself. classinfo may be a tuple of class objects, in which case every entry in classinfo will be checked. In any other case, a TypeError exception is raised.&lt;/p&gt;

&lt;p&gt;Changed in version 2.3: Support for a tuple of type information was added.&lt;/p&gt;

&lt;p&gt;iter(o[, sentinel]) 
Return an iterator object. The first argument is interpreted very differently depending on the presence of the second argument. Without a second argument, o must be a collection object which supports the iteration protocol (the &lt;strong&gt;iter&lt;/strong&gt;() method), or it must support the sequence protocol (the &lt;strong&gt;getitem&lt;/strong&gt;() method with integer arguments starting at 0). If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel, is given, then o must be a callable object. The iterator created in this case will call o with no arguments for each call to its next() method; if the value returned is equal to sentinel, StopIteration will be raised, otherwise the value will be returned.&lt;/p&gt;

&lt;p&gt;One useful application of the second form of iter() is to read lines of a file until a certain line is reached. The following example reads a file until the readline() method returns an empty string:&lt;/p&gt;

&lt;p&gt;with open(&amp;#39;mydata.txt&amp;#39;) as fp:
    for line in iter(fp.readline, &amp;#39;&amp;#39;):
        process_line(line)
New in version 2.2.&lt;/p&gt;

&lt;p&gt;len(s) 
Return the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set).&lt;/p&gt;

&lt;p&gt;list([iterable]) 
Return a list whose items are the same and in the same order as iterable‘s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to iterable[:]. For instance, list(&amp;#39;abc&amp;#39;) returns [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;] and list( (1, 2, 3) ) returns [1, 2, 3]. If no argument is given, returns a new empty list, [].&lt;/p&gt;

&lt;p&gt;list is a mutable sequence type, as documented in Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange. For other containers see the built in dict, set, and tuple classes, and the collections module.&lt;/p&gt;

&lt;p&gt;locals() 
Update and return a dictionary representing the current local symbol table. Free variables are returned by locals() when it is called in function blocks, but not in class blocks.&lt;/p&gt;

&lt;p&gt;Note
The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.&lt;/p&gt;

&lt;p&gt;long(x=0) 
long(x, base=10) 
Convert a string or number to a long integer. If the argument is a string, it must contain a possibly signed number of arbitrary size, possibly embedded in whitespace. The base argument is interpreted in the same way as for int(), and may only be given when x is a string. Otherwise, the argument may be a plain or long integer or a floating point number, and a long integer with the same value is returned. Conversion of floating point numbers to integers truncates (towards zero). If no arguments are given, returns 0L.&lt;/p&gt;

&lt;p&gt;The long type is described in Numeric Types — int, float, long, complex.&lt;/p&gt;

&lt;p&gt;map(function, iterable, ...) 
Apply function to every item of iterable and return a list of the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. If one iterable is shorter than another it is assumed to be extended with None items. If function is None, the identity function is assumed; if there are multiple arguments, map() returns a list consisting of tuples containing the corresponding items from all iterables (a kind of transpose operation). The iterable arguments may be a sequence or any iterable object; the result is always a list.&lt;/p&gt;

&lt;p&gt;max(iterable[, key]) 
max(arg1, arg2, *args[, key]) 
Return the largest item in an iterable or the largest of two or more arguments.&lt;/p&gt;

&lt;p&gt;If one positional argument is provided, iterable must be a non-empty iterable (such as a non-empty string, tuple or list). The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned.&lt;/p&gt;

&lt;p&gt;The optional key argument specifies a one-argument ordering function like that used for list.sort(). The key argument, if supplied, must be in keyword form (for example, max(a,b,c,key=func)).&lt;/p&gt;

&lt;p&gt;Changed in version 2.5: Added support for the optional key argument.&lt;/p&gt;

&lt;p&gt;memoryview(obj) 
Return a “memory view” object created from the given argument. See memoryview type for more information.&lt;/p&gt;

&lt;p&gt;min(iterable[, key]) 
min(arg1, arg2, *args[, key]) 
Return the smallest item in an iterable or the smallest of two or more arguments.&lt;/p&gt;

&lt;p&gt;If one positional argument is provided, iterable must be a non-empty iterable (such as a non-empty string, tuple or list). The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned.&lt;/p&gt;

&lt;p&gt;The optional key argument specifies a one-argument ordering function like that used for list.sort(). The key argument, if supplied, must be in keyword form (for example, min(a,b,c,key=func)).&lt;/p&gt;

&lt;p&gt;Changed in version 2.5: Added support for the optional key argument.&lt;/p&gt;

&lt;p&gt;next(iterator[, default]) 
Retrieve the next item from the iterator by calling its next() method. If default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised.&lt;/p&gt;

&lt;p&gt;New in version 2.6.&lt;/p&gt;

&lt;p&gt;object() 
Return a new featureless object. object is a base for all new style classes. It has the methods that are common to all instances of new style classes.&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;Changed in version 2.3: This function does not accept any arguments. Formerly, it accepted arguments but ignored them.&lt;/p&gt;

&lt;p&gt;oct(x) 
Convert an integer number (of any size) to an octal string. The result is a valid Python expression.&lt;/p&gt;

&lt;p&gt;Changed in version 2.4: Formerly only returned an unsigned literal.&lt;/p&gt;

&lt;p&gt;open(name[, mode[, buffering]]) 
Open a file, returning an object of the file type described in section File Objects. If the file cannot be opened, IOError is raised. When opening a file, it’s preferable to use open() instead of invoking the file constructor directly.&lt;/p&gt;

&lt;p&gt;The first two arguments are the same as for stdio‘s fopen(): name is the file name to be opened, and mode is a string indicating how the file is to be opened.&lt;/p&gt;

&lt;p&gt;The most commonly-used values of mode are &amp;#39;r&amp;#39; for reading, &amp;#39;w&amp;#39; for writing (truncating the file if it already exists), and &amp;#39;a&amp;#39; for appending (which on some Unix systems means that all writes append to the end of the file regardless of the current seek position). If mode is omitted, it defaults to &amp;#39;r&amp;#39;. The default is to use text mode, which may convert &amp;#39;\n&amp;#39; characters to a platform-specific representation on writing and back on reading. Thus, when opening a binary file, you should append &amp;#39;b&amp;#39; to the mode value to open the file in binary mode, which will improve portability. (Appending &amp;#39;b&amp;#39; is useful even on systems that don’t treat binary and text files differently, where it serves as documentation.) See below for more possible values of mode.&lt;/p&gt;

&lt;p&gt;The optional buffering argument specifies the file’s desired buffer size: 0 means unbuffered, 1 means line buffered, any other positive value means use a buffer of (approximately) that size (in bytes). A negative buffering means to use the system default, which is usually line buffered for tty devices and fully buffered for other files. If omitted, the system default is used. [2]&lt;/p&gt;

&lt;p&gt;Modes &amp;#39;r+&amp;#39;, &amp;#39;w+&amp;#39; and &amp;#39;a+&amp;#39; open the file for updating (reading and writing); note that &amp;#39;w+&amp;#39; truncates the file. Append &amp;#39;b&amp;#39; to the mode to open the file in binary mode, on systems that differentiate between binary and text files; on systems that don’t have this distinction, adding the &amp;#39;b&amp;#39; has no effect.&lt;/p&gt;

&lt;p&gt;In addition to the standard fopen() values mode may be &amp;#39;U&amp;#39; or &amp;#39;rU&amp;#39;. Python is usually built with universal newlines support; supplying &amp;#39;U&amp;#39; opens the file as a text file, but lines may be terminated by any of the following: the Unix end-of-line convention &amp;#39;\n&amp;#39;, the Macintosh convention &amp;#39;\r&amp;#39;, or the Windows convention &amp;#39;\r\n&amp;#39;. All of these external representations are seen as &amp;#39;\n&amp;#39; by the Python program. If Python is built without universal newlines support a mode with &amp;#39;U&amp;#39; is the same as normal text mode. Note that file objects so opened also have an attribute called newlines which has a value of None (if no newlines have yet been seen), &amp;#39;\n&amp;#39;, &amp;#39;\r&amp;#39;, &amp;#39;\r\n&amp;#39;, or a tuple containing all the newline types seen.&lt;/p&gt;

&lt;p&gt;Python enforces that the mode, after stripping &amp;#39;U&amp;#39;, begins with &amp;#39;r&amp;#39;, &amp;#39;w&amp;#39; or &amp;#39;a&amp;#39;.&lt;/p&gt;

&lt;p&gt;Python provides many file handling modules including fileinput, os, os.path, tempfile, and shutil.&lt;/p&gt;

&lt;p&gt;Changed in version 2.5: Restriction on first letter of mode string introduced.&lt;/p&gt;

&lt;p&gt;ord(c) 
Given a string of length one, return an integer representing the Unicode code point of the character when the argument is a unicode object, or the value of the byte when the argument is an 8-bit string. For example, ord(&amp;#39;a&amp;#39;) returns the integer 97, ord(u&amp;#39;\u2020&amp;#39;) returns 8224. This is the inverse of chr() for 8-bit strings and of unichr() for unicode objects. If a unicode argument is given and Python was built with UCS2 Unicode, then the character’s code point must be in the range [0..65535] inclusive; otherwise the string length is two, and a TypeError will be raised.&lt;/p&gt;

&lt;p&gt;pow(x, y[, z]) 
Return x to the power y; if z is present, return x to the power y, modulo z (computed more efficiently than pow(x, y) % z). The two-argument form pow(x, y) is equivalent to using the power operator: x**y.&lt;/p&gt;

&lt;p&gt;The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For int and long int operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, 10&lt;strong&gt;2 returns 100, but 10&lt;/strong&gt;-2 returns 0.01. (This last feature was added in Python 2.2. In Python 2.1 and before, if both arguments were of integer types and the second argument was negative, an exception was raised.) If the second argument is negative, the third argument must be omitted. If z is present, x and y must be of integer types, and y must be non-negative. (This restriction was added in Python 2.2. In Python 2.1 and before, floating 3-argument pow() returned platform-dependent results depending on floating-point rounding accidents.)&lt;/p&gt;

&lt;p&gt;print(*objects, sep=&amp;#39; &amp;#39;, end=&amp;#39;\n&amp;#39;, file=sys.stdout) 
Print objects to the stream file, separated by sep and followed by end. sep, end and file, if present, must be given as keyword arguments.&lt;/p&gt;

&lt;p&gt;All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end.&lt;/p&gt;

&lt;p&gt;The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Output buffering is determined by file. Use file.flush() to ensure, for instance, immediate appearance on a screen.&lt;/p&gt;

&lt;p&gt;Note
This function is not normally available as a built-in since the name print is recognized as the print statement. To disable the statement and use the print() function, use this future statement at the top of your module:&lt;/p&gt;

&lt;p&gt;from &lt;strong&gt;future&lt;/strong&gt; import print_function
New in version 2.6.&lt;/p&gt;

&lt;p&gt;property([fget[, fset[, fdel[, doc]]]]) 
Return a property attribute for new-style classes (classes that derive from object).&lt;/p&gt;

&lt;p&gt;fget is a function for getting an attribute value, likewise fset is a function for setting, and fdel a function for del’ing, an attribute. Typical use is to define a managed attribute x:&lt;/p&gt;

&lt;p&gt;class C(object):
    def &lt;strong&gt;init&lt;/strong&gt;(self):
        self._x = None&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def getx(self):
    return self._x
def setx(self, value):
    self._x = value
def delx(self):
    del self._x
x = property(getx, setx, delx, &amp;quot;I&amp;#39;m the &amp;#39;x&amp;#39; property.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If then c is an instance of C, c.x will invoke the getter, c.x = value will invoke the setter and del c.x the deleter.&lt;/p&gt;

&lt;p&gt;If given, doc will be the docstring of the property attribute. Otherwise, the property will copy fget‘s docstring (if it exists). This makes it possible to create read-only properties easily using property() as a decorator:&lt;/p&gt;

&lt;p&gt;class Parrot(object):
    def &lt;strong&gt;init&lt;/strong&gt;(self):
        self._voltage = 100000&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@property
def voltage(self):
    &amp;quot;&amp;quot;&amp;quot;Get the current voltage.&amp;quot;&amp;quot;&amp;quot;
    return self._voltage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;turns the voltage() method into a “getter” for a read-only attribute with the same name.&lt;/p&gt;

&lt;p&gt;A property object has getter, setter, and deleter methods usable as decorators that create a copy of the property with the corresponding accessor function set to the decorated function. This is best explained with an example:&lt;/p&gt;

&lt;p&gt;class C(object):
    def &lt;strong&gt;init&lt;/strong&gt;(self):
        self._x = None&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@property
def x(self):
    &amp;quot;&amp;quot;&amp;quot;I&amp;#39;m the &amp;#39;x&amp;#39; property.&amp;quot;&amp;quot;&amp;quot;
    return self._x

@x.setter
def x(self, value):
    self._x = value

@x.deleter
def x(self):
    del self._x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code is exactly equivalent to the first example. Be sure to give the additional functions the same name as the original property (x in this case.)&lt;/p&gt;

&lt;p&gt;The returned property also has the attributes fget, fset, and fdel corresponding to the constructor arguments.&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;Changed in version 2.5: Use fget‘s docstring if no doc given.&lt;/p&gt;

&lt;p&gt;Changed in version 2.6: The getter, setter, and deleter attributes were added.&lt;/p&gt;

&lt;p&gt;range(stop) 
range(start, stop[, step]) 
This is a versatile function to create lists containing arithmetic progressions. It is most often used in for loops. The arguments must be plain integers. If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. The full form returns a list of plain integers [start, start + step, start + 2 * step, ...]. If step is positive, the last element is the largest start + i * step less than stop; if step is negative, the last element is the smallest start + i * step greater than stop. step must not be zero (or else ValueError is raised). Example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
range(1, 11)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
range(0, 30, 5)
[0, 5, 10, 15, 20, 25]
range(0, 10, 3)
[0, 3, 6, 9]
range(0, -10, -1)
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
range(0)
[]
range(1, 0)
[]
raw_input([prompt]) 
If the prompt argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, EOFError is raised. Example:&lt;/p&gt;

&lt;p&gt;s = raw&lt;em&gt;input(&amp;#39;--&amp;gt; &amp;#39;)
--&amp;gt; Monty Python&amp;#39;s Flying Circus
s
&amp;quot;Monty Python&amp;#39;s Flying Circus&amp;quot;
If the readline module was loaded, then raw&lt;/em&gt;input() will use it to provide elaborate line editing and history features.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;reduce(function, iterable[, initializer]) 
Apply function of two arguments cumulatively to the items of iterable, from left to right, so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y, is the update value from the iterable. If the optional initializer is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If initializer is not given and iterable contains only one item, the first item is returned. Roughly equivalent to:&lt;/p&gt;

&lt;p&gt;def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        try:
            initializer = next(it)
        except StopIteration:
            raise TypeError(&amp;#39;reduce() of empty sequence with no initial value&amp;#39;)
    accum&lt;em&gt;value = initializer
    for x in it:
        accum&lt;/em&gt;value = function(accum&lt;em&gt;value, x)
    return accum&lt;/em&gt;value
reload(module) 
Reload a previously imported module. The argument must be a module object, so it must have been successfully imported before. This is useful if you have edited the module source file using an external editor and want to try out the new version without leaving the Python interpreter. The return value is the module object (the same as the module argument).&lt;/p&gt;

&lt;p&gt;When reload(module) is executed:&lt;/p&gt;

&lt;p&gt;Python modules’ code is recompiled and the module-level code reexecuted, defining a new set of objects which are bound to names in the module’s dictionary. The init function of extension modules is not called a second time. 
As with all other objects in Python the old objects are only reclaimed after their reference counts drop to zero. 
The names in the module namespace are updated to point to any new or changed objects. 
Other references to the old objects (such as names external to the module) are not rebound to refer to the new objects and must be updated in each namespace where they occur if that is desired. 
There are a number of other caveats:&lt;/p&gt;

&lt;p&gt;If a module is syntactically correct but its initialization fails, the first import statement for it does not bind its name locally, but does store a (partially initialized) module object in sys.modules. To reload the module you must first import it again (this will bind the name to the partially initialized module object) before you can reload() it.&lt;/p&gt;

&lt;p&gt;When a module is reloaded, its dictionary (containing the module’s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module’s advantage if it maintains a global table or cache of objects — with a try statement it can test for the table’s presence and skip its initialization if desired:&lt;/p&gt;

&lt;p&gt;try:
    cache
except NameError:
    cache = {}
It is legal though generally not very useful to reload built-in or dynamically loaded modules, except for sys, &lt;strong&gt;main&lt;/strong&gt; and &lt;strong&gt;builtin&lt;/strong&gt;. In many cases, however, extension modules are not designed to be initialized more than once, and may fail in arbitrary ways when reloaded.&lt;/p&gt;

&lt;p&gt;If a module imports objects from another module using from ... import ..., calling reload() for the other module does not redefine the objects imported from it — one way around this is to re-execute the from statement, another is to use import and qualified names (module.&lt;em&gt;name&lt;/em&gt;) instead.&lt;/p&gt;

&lt;p&gt;If a module instantiates instances of a class, reloading the module that defines the class does not affect the method definitions of the instances — they continue to use the old class definition. The same is true for derived classes.&lt;/p&gt;

&lt;p&gt;repr(object) 
Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse quotes). It is sometimes useful to be able to access this operation as an ordinary function. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a &lt;strong&gt;repr&lt;/strong&gt;() method.&lt;/p&gt;

&lt;p&gt;reversed(seq) 
Return a reverse iterator. seq must be an object which has a &lt;strong&gt;reversed&lt;/strong&gt;() method or supports the sequence protocol (the &lt;strong&gt;len&lt;/strong&gt;() method and the &lt;strong&gt;getitem&lt;/strong&gt;() method with integer arguments starting at 0).&lt;/p&gt;

&lt;p&gt;New in version 2.4.&lt;/p&gt;

&lt;p&gt;Changed in version 2.6: Added the possibility to write a custom &lt;strong&gt;reversed&lt;/strong&gt;() method.&lt;/p&gt;

&lt;p&gt;round(number[, ndigits]) 
Return the floating point value number rounded to ndigits digits after the decimal point. If ndigits is omitted, it defaults to zero. The result is a floating point number. Values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done away from 0 (so. for example, round(0.5) is 1.0 and round(-0.5) is -1.0).&lt;/p&gt;

&lt;p&gt;Note
The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68. This is not a bug: it’s a result of the fact that most decimal fractions can’t be represented exactly as a float. See Floating Point Arithmetic: Issues and Limitations for more information.&lt;/p&gt;

&lt;p&gt;set([iterable]) 
Return a new set object, optionally with elements taken from iterable. set is a built-in class. See set and Set Types — set, frozenset for documentation about this class.&lt;/p&gt;

&lt;p&gt;For other containers see the built-in frozenset, list, tuple, and dict classes, as well as the collections module.&lt;/p&gt;

&lt;p&gt;New in version 2.4.&lt;/p&gt;

&lt;p&gt;setattr(object, name, value) 
This is the counterpart of getattr(). The arguments are an object, a string and an arbitrary value. The string may name an existing attribute or a new attribute. The function assigns the value to the attribute, provided the object allows it. For example, setattr(x, &amp;#39;foobar&amp;#39;, 123) is equivalent to x.foobar = 123.&lt;/p&gt;

&lt;p&gt;slice(stop) 
slice(start, stop[, step]) 
Return a slice object representing the set of indices specified by range(start, stop, step). The start and step arguments default to None. Slice objects have read-only data attributes start, stop and step which merely return the argument values (or their default). They have no other explicit functionality; however they are used by Numerical Python and other third party extensions. Slice objects are also generated when extended indexing syntax is used. For example: a[start:stop:step] or a[start:stop, i]. See itertools.islice() for an alternate version that returns an iterator.&lt;/p&gt;

&lt;p&gt;sorted(iterable[, cmp[, key[, reverse]]]) 
Return a new sorted list from the items in iterable.&lt;/p&gt;

&lt;p&gt;The optional arguments cmp, key, and reverse have the same meaning as those for the list.sort() method (described in section Mutable Sequence Types).&lt;/p&gt;

&lt;p&gt;cmp specifies a custom comparison function of two arguments (iterable elements) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument: cmp=lambda x,y: cmp(x.lower(), y.lower()). The default value is None.&lt;/p&gt;

&lt;p&gt;key specifies a function of one argument that is used to extract a comparison key from each list element: key=str.lower. The default value is None (compare the elements directly).&lt;/p&gt;

&lt;p&gt;reverse is a boolean value. If set to True, then the list elements are sorted as if each comparison were reversed.&lt;/p&gt;

&lt;p&gt;In general, the key and reverse conversion processes are much faster than specifying an equivalent cmp function. This is because cmp is called multiple times for each list element while key and reverse touch each element only once. Use functools.cmp&lt;em&gt;to&lt;/em&gt;key() to convert an old-style cmp function to a key function.&lt;/p&gt;

&lt;p&gt;For sorting examples and a brief sorting tutorial, see Sorting HowTo.&lt;/p&gt;

&lt;p&gt;New in version 2.4.&lt;/p&gt;

&lt;p&gt;staticmethod(function) 
Return a static method for function.&lt;/p&gt;

&lt;p&gt;A static method does not receive an implicit first argument. To declare a static method, use this idiom:&lt;/p&gt;

&lt;p&gt;class C(object):
    @staticmethod
    def f(arg1, arg2, ...):
        ...
The @staticmethod form is a function decorator – see the description of function definitions in Function definitions for details.&lt;/p&gt;

&lt;p&gt;It can be called either on the class (such as C.f()) or on an instance (such as C().f()). The instance is ignored except for its class.&lt;/p&gt;

&lt;p&gt;Static methods in Python are similar to those found in Java or C++. Also see classmethod() for a variant that is useful for creating alternate class constructors.&lt;/p&gt;

&lt;p&gt;For more information on static methods, consult the documentation on the standard type hierarchy in The standard type hierarchy.&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;Changed in version 2.4: Function decorator syntax added.&lt;/p&gt;

&lt;p&gt;str(object=&amp;#39;&amp;#39;) 
Return a string containing a nicely printable representation of an object. For strings, this returns the string itself. The difference with repr(object) is that str(object) does not always attempt to return a string that is acceptable to eval(); its goal is to return a printable string. If no argument is given, returns the empty string, &amp;#39;&amp;#39;.&lt;/p&gt;

&lt;p&gt;For more information on strings see Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange which describes sequence functionality (strings are sequences), and also the string-specific methods described in the String Methods section. To output formatted strings use template strings or the % operator described in the String Formatting Operations section. In addition see the String Services section. See also unicode().&lt;/p&gt;

&lt;p&gt;sum(iterable[, start]) 
Sums start and the items of an iterable from left to right and returns the total. start defaults to 0. The iterable‘s items are normally numbers, and the start value is not allowed to be a string.&lt;/p&gt;

&lt;p&gt;For some use cases, there are good alternatives to sum(). The preferred, fast way to concatenate a sequence of strings is by calling &amp;#39;&amp;#39;.join(sequence). To add floating point values with extended precision, see math.fsum(). To concatenate a series of iterables, consider using itertools.chain().&lt;/p&gt;

&lt;p&gt;New in version 2.3.&lt;/p&gt;

&lt;p&gt;super(type[, object-or-type]) 
Return a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The search order is same as that used by getattr() except that the type itself is skipped.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;mro&lt;/strong&gt; attribute of the type lists the method resolution search order used by both getattr() and super(). The attribute is dynamic and can change whenever the inheritance hierarchy is updated.&lt;/p&gt;

&lt;p&gt;If the second argument is omitted, the super object returned is unbound. If the second argument is an object, isinstance(obj, type) must be true. If the second argument is a type, issubclass(type2, type) must be true (this is useful for classmethods).&lt;/p&gt;

&lt;p&gt;Note
super() only works for new-style classes.&lt;/p&gt;

&lt;p&gt;There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages.&lt;/p&gt;

&lt;p&gt;The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that this method have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime).&lt;/p&gt;

&lt;p&gt;For both use cases, a typical superclass call looks like this:&lt;/p&gt;

&lt;p&gt;class C(B):
    def method(self, arg):
        super(C, self).method(arg)
Note that super() is implemented as part of the binding process for explicit dotted attribute lookups such as super().&lt;strong&gt;getitem&lt;/strong&gt;(name). It does so by implementing its own &lt;strong&gt;getattribute&lt;/strong&gt;() method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, super() is undefined for implicit lookups using statements or operators such as super()[name].&lt;/p&gt;

&lt;p&gt;Also note that super() is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references.&lt;/p&gt;

&lt;p&gt;For practical suggestions on how to design cooperative classes using super(), see guide to using super().&lt;/p&gt;

&lt;p&gt;New in version 2.2.&lt;/p&gt;

&lt;p&gt;tuple([iterable]) 
Return a tuple whose items are the same and in the same order as iterable‘s items. iterable may be a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For instance, tuple(&amp;#39;abc&amp;#39;) returns (&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;) and tuple([1, 2, 3]) returns (1, 2, 3). If no argument is given, returns a new empty tuple, ().&lt;/p&gt;

&lt;p&gt;tuple is an immutable sequence type, as documented in Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange. For other containers see the built in dict, list, and set classes, and the collections module.&lt;/p&gt;

&lt;p&gt;type(object) 
type(name, bases, dict) 
With one argument, return the type of an object. The return value is a type object. The isinstance() built-in function is recommended for testing the type of an object.&lt;/p&gt;

&lt;p&gt;With three arguments, return a new type object. This is essentially a dynamic form of the class statement. The name string is the class name and becomes the &lt;strong&gt;name&lt;/strong&gt; attribute; the bases tuple itemizes the base classes and becomes the &lt;strong&gt;bases&lt;/strong&gt; attribute; and the dict dictionary is the namespace containing definitions for class body and becomes the &lt;strong&gt;dict&lt;/strong&gt; attribute. For example, the following two statements create identical type objects:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;class X(object):
...     a = 1
...
X = type(&amp;#39;X&amp;#39;, (object,), dict(a=1))
New in version 2.2.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;unichr(i) 
Return the Unicode string of one character whose Unicode code is the integer i. For example, unichr(97) returns the string u&amp;#39;a&amp;#39;. This is the inverse of ord() for Unicode strings. The valid range for the argument depends how Python was configured – it may be either UCS2 [0..0xFFFF] or UCS4 [0..0x10FFFF]. ValueError is raised otherwise. For ASCII and 8-bit strings see chr().&lt;/p&gt;

&lt;p&gt;New in version 2.0.&lt;/p&gt;

&lt;p&gt;unicode(object=&amp;#39;&amp;#39;) 
unicode(object[, encoding[, errors]]) 
Return the Unicode string version of object using one of the following modes:&lt;/p&gt;

&lt;p&gt;If encoding and/or errors are given, unicode() will decode the object which can either be an 8-bit string or a character buffer using the codec for encoding. The encoding parameter is a string giving the name of an encoding; if the encoding is not known, LookupError is raised. Error handling is done according to errors; this specifies the treatment of characters which are invalid in the input encoding. If errors is &amp;#39;strict&amp;#39; (the default), a ValueError is raised on errors, while a value of &amp;#39;ignore&amp;#39; causes errors to be silently ignored, and a value of &amp;#39;replace&amp;#39; causes the official Unicode replacement character, U+FFFD, to be used to replace input characters which cannot be decoded. See also the codecs module.&lt;/p&gt;

&lt;p&gt;If no optional parameters are given, unicode() will mimic the behaviour of str() except that it returns Unicode strings instead of 8-bit strings. More precisely, if object is a Unicode string or subclass it will return that Unicode string without any additional decoding applied.&lt;/p&gt;

&lt;p&gt;For objects which provide a &lt;strong&gt;unicode&lt;/strong&gt;() method, it will call this method without arguments to create a Unicode string. For all other objects, the 8-bit string version or representation is requested and then converted to a Unicode string using the codec for the default encoding in &amp;#39;strict&amp;#39; mode.&lt;/p&gt;

&lt;p&gt;For more information on Unicode strings see Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange which describes sequence functionality (Unicode strings are sequences), and also the string-specific methods described in the String Methods section. To output formatted strings use template strings or the % operator described in the String Formatting Operations section. In addition see the String Services section. See also str().&lt;/p&gt;

&lt;p&gt;New in version 2.0.&lt;/p&gt;

&lt;p&gt;Changed in version 2.2: Support for &lt;strong&gt;unicode&lt;/strong&gt;() added.&lt;/p&gt;

&lt;p&gt;vars([object]) 
Return the &lt;strong&gt;dict&lt;/strong&gt; attribute for a module, class, instance, or any other object with a &lt;strong&gt;dict&lt;/strong&gt; attribute.&lt;/p&gt;

&lt;p&gt;Objects such as modules and instances have an updateable &lt;strong&gt;dict&lt;/strong&gt; attribute; however, other objects may have write restrictions on their &lt;strong&gt;dict&lt;/strong&gt; attributes (for example, new-style classes use a dictproxy to prevent direct dictionary updates).&lt;/p&gt;

&lt;p&gt;Without an argument, vars() acts like locals(). Note, the locals dictionary is only useful for reads since updates to the locals dictionary are ignored.&lt;/p&gt;

&lt;p&gt;xrange(stop) 
xrange(start, stop[, step]) 
This function is very similar to range(), but returns an xrange object instead of a list. This is an opaque sequence type which yields the same values as the corresponding list, without actually storing them all simultaneously. The advantage of xrange() over range() is minimal (since xrange() still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the range’s elements are never used (such as when the loop is usually terminated with break). For more information on xrange objects, see XRange Type and Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange.&lt;/p&gt;

&lt;p&gt;CPython implementation detail: xrange() is intended to be simple and fast. Implementations may impose restrictions to achieve this. The C implementation of Python restricts all arguments to native C longs (“short” Python integers), and also requires that the number of elements fit in a native C long. If a larger range is needed, an alternate version can be crafted using the itertools module: islice(count(start, step), (stop-start+step-1+2*(step&amp;lt;0))//step).&lt;/p&gt;

&lt;p&gt;zip([iterable, ...]) 
This function returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The returned list is truncated in length to the length of the shortest argument sequence. When there are multiple arguments which are all of the same length, zip() is similar to map() with an initial argument of None. With a single sequence argument, it returns a list of 1-tuples. With no arguments, it returns an empty list.&lt;/p&gt;

&lt;p&gt;The left-to-right evaluation order of the iterables is guaranteed. This makes possible an idiom for clustering a data series into n-length groups using zip(&lt;em&gt;[iter(s)]&lt;/em&gt;n).&lt;/p&gt;

&lt;p&gt;zip() in conjunction with the * operator can be used to unzip a list:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
zipped
[(1, 4), (2, 5), (3, 6)]
x2, y2 = zip(*zipped)
x == list(x2) and y == list(y2)
True
New in version 2.0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Changed in version 2.4: Formerly, zip() required at least one argument and zip() raised a TypeError instead of returning an empty list.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;import&lt;/strong&gt;(name[, globals[, locals[, fromlist[, level]]]]) 
Note
This is an advanced function that is not needed in everyday Python programming, unlike importlib.import_module().&lt;/p&gt;

&lt;p&gt;This function is invoked by the import statement. It can be replaced (by importing the &lt;strong&gt;builtin&lt;/strong&gt; module and assigning to &lt;strong&gt;builtin&lt;/strong&gt;.&lt;strong&gt;import&lt;/strong&gt;) in order to change semantics of the import statement, but nowadays it is usually simpler to use import hooks (see PEP 302). Direct use of &lt;strong&gt;import&lt;/strong&gt;() is rare, except in cases where you want to import a module whose name is only known at runtime.&lt;/p&gt;

&lt;p&gt;The function imports the module name, potentially using the given globals and locals to determine how to interpret the name in a package context. The fromlist gives the names of objects or submodules that should be imported from the module given by name. The standard implementation does not use its locals argument at all, and uses its globals only to determine the package context of the import statement.&lt;/p&gt;

&lt;p&gt;level specifies whether to use absolute or relative imports. The default is -1 which indicates both absolute and relative imports will be attempted. 0 means only perform absolute imports. Positive values for level indicate the number of parent directories to search relative to the directory of the module calling &lt;strong&gt;import&lt;/strong&gt;().&lt;/p&gt;

&lt;p&gt;When the name variable is of the form package.module, normally, the top-level package (the name up till the first dot) is returned, not the module named by name. However, when a non-empty fromlist argument is given, the module named by name is returned.&lt;/p&gt;

&lt;p&gt;For example, the statement import spam results in bytecode resembling the following code:&lt;/p&gt;

&lt;p&gt;spam = &lt;strong&gt;import&lt;/strong&gt;(&amp;#39;spam&amp;#39;, globals(), locals(), [], -1)
The statement import spam.ham results in this call:&lt;/p&gt;

&lt;p&gt;spam = &lt;strong&gt;import&lt;/strong&gt;(&amp;#39;spam.ham&amp;#39;, globals(), locals(), [], -1)
Note how &lt;strong&gt;import&lt;/strong&gt;() returns the toplevel module here because this is the object that is bound to a name by the import statement.&lt;/p&gt;

&lt;p&gt;On the other hand, the statement from spam.ham import eggs, sausage as saus results in&lt;/p&gt;

&lt;p&gt;&lt;em&gt;temp = _&lt;/em&gt;import&lt;strong&gt;(&amp;#39;spam.ham&amp;#39;, globals(), locals(), [&amp;#39;eggs&amp;#39;, &amp;#39;sausage&amp;#39;], -1)
eggs = &lt;em&gt;temp.eggs
saus = _temp.sausage
Here, the spam.ham module is returned from _&lt;/em&gt;import&lt;/strong&gt;(). From this object, the names to import are retrieved and assigned to their respective names.&lt;/p&gt;

&lt;p&gt;If you simply want to import a module (potentially within a package) by name, use importlib.import_module().&lt;/p&gt;

&lt;p&gt;Changed in version 2.5: The level parameter was added.&lt;/p&gt;

&lt;p&gt;Changed in version 2.5: Keyword support for parameters was added.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Non-essential Built-in Functions
There are several built-in functions that are no longer essential to learn, know or use in modern Python programming. They have been kept here to maintain backwards compatibility with programs written for older versions of Python.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Python programmers, trainers, students and book writers should feel free to bypass these functions without concerns about missing something important.&lt;/p&gt;

&lt;p&gt;apply(function, args[, keywords]) 
The function argument must be a callable object (a user-defined or built-in function or method, or a class object) and the args argument must be a sequence. The function is called with args as the argument list; the number of arguments is the length of the tuple. If the optional keywords argument is present, it must be a dictionary whose keys are strings. It specifies keyword arguments to be added to the end of the argument list. Calling apply() is different from just calling function(args), since in that case there is always exactly one argument. The use of apply() is equivalent to function(&lt;em&gt;args, *&lt;/em&gt;keywords).&lt;/p&gt;

&lt;p&gt;Deprecated since version 2.3: Use function(&lt;em&gt;args, *&lt;/em&gt;keywords) instead of apply(function, args, keywords) (see Unpacking Argument Lists).&lt;/p&gt;

&lt;p&gt;buffer(object[, offset[, size]]) 
The object argument must be an object that supports the buffer call interface (such as strings, arrays, and buffers). A new buffer object will be created which references the object argument. The buffer object will be a slice from the beginning of object (or from the specified offset). The slice will extend to the end of object (or will have a length given by the size argument).&lt;/p&gt;

&lt;p&gt;coerce(x, y) 
Return a tuple consisting of the two numeric arguments converted to a common type, using the same rules as used by arithmetic operations. If coercion is not possible, raise TypeError.&lt;/p&gt;

&lt;p&gt;intern(string) 
Enter string in the table of “interned” strings and return the interned string – which is string itself or a copy. Interning strings is useful to gain a little performance on dictionary lookup – if the keys in a dictionary are interned, and the lookup key is interned, the key comparisons (after hashing) can be done by a pointer compare instead of a string compare. Normally, the names used in Python programs are automatically interned, and the dictionaries used to hold module, class or instance attributes have interned keys.&lt;/p&gt;

&lt;p&gt;Changed in version 2.3: Interned strings are not immortal (like they used to be in Python 2.2 and before); you must keep a reference to the return value of intern() around to benefit from it.&lt;/p&gt;

&lt;p&gt;Footnotes&lt;/p&gt;

&lt;p&gt;[1] It is used relatively rarely so does not warrant being made into a statement. 
[2] Specifying a buffer size currently has no effect on systems that don’t have setvbuf(). The interface to specify the buffer size is not done using a method that calls setvbuf(), because that may dump core when called after any I/O has been performed, and there’s no reliable way to determine whether this is the case. 
[3] In the current implementation, local variable bindings cannot normally be affected this way, but variables retrieved from other scopes (such as modules) can be. This may change. 
Navigation
index modules | next | previous |  Python » Python 2.7.8 documentation » The Python Standard Library » © Copyright 1990-2014, Python Software Foundation. 
The Python Software Foundation is a non-profit corporation. Please donate. 
Last updated on Jun 30, 2014. Found a bug? 
Created using Sphinx 1.1.3. &lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Two</title>
        <link>http://eledata.github.io/2014/09/18/Learn-Python-Exercise-Two.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/18/Learn-Python-Exercise-Two.html</guid>
        <pubDate>Thu, 18 Sep 2014 00:00:00 +0800</pubDate>
        <description></description>
      </item>
    
      <item>
        <title>Linux 2：文件权限与目录配置</title>
        <link>http://eledata.github.io/2014/09/17/Linux2.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/17/Linux2.html</guid>
        <pubDate>Wed, 17 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Linux最优秀的地方之一，就在于它的多用户、多任务环境。Linux一般将文件可存取访问的身份分为3个类别，分别是owner（用户）、group（用户组）、others（其他人），且3种身份都各自有自己的read，write，execute等权限。&lt;/p&gt;

&lt;h3&gt;用户身份与用户组记录的文件&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;\etc\passwd     #所有系统账号的相关信息
\etc\shadow     #个人的密码
\etc\group      #Linux所有的组名
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;文件权限概念&lt;/h3&gt;

&lt;p&gt;当屏幕前面出现“Permission deny”的时候，肯定是权限设置错误。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ls -al          #ls:list，列出所有文件的详细信息
ls -l           #显示文件，属性的第一个字段是文件的权限，共10位，比如-rwxr-xr--，表示owner具有rwx权限，group具有rx权限，others只具有r权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;改变文件属性与权限&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;chgrp       #改变文件所属用户组，具体句法记得使用 man page 查询
chown -R 用户账号:所在组群 文件名      #改变文件所有者
chmod       #改变文件的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，chmod修改权限的方法有两种，分别是符号法与数字法，数字法中r，w，x的数值分别是4，2，1。&lt;/p&gt;

&lt;p&gt;要开放“目录”（注意不是“文件”）给任何人看，应该至少同时给予r和x权限，但w权限不可随便给予。&lt;/p&gt;

&lt;h3&gt;文件种类与扩展名&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;ls -l&lt;/code&gt;查看到的十个字符中，第一个字符为文件的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-: 普通文件（regular file）&lt;/li&gt;
&lt;li&gt;d: 目录文件（directory）&lt;/li&gt;
&lt;li&gt;l: 连接文件，类似于windows的快捷方式（link）&lt;/li&gt;
&lt;li&gt;b: 块设备文件（block）&lt;/li&gt;
&lt;li&gt;c: 字符设备文件（character）&lt;/li&gt;
&lt;li&gt;s: 套接字（sockets）&lt;/li&gt;
&lt;li&gt;p: 管道（FIFO, pipe）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Linux目录配置标准：FHS&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/linuxDIRTREE.gif&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;根据FHS的定义，最好将&lt;code&gt;/var&lt;/code&gt;独立出来，这样至少/var死掉的时候，根目录还活着，还能够进入救援模式。&lt;/p&gt;

&lt;h3&gt;绝对路径与相对路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;cd/var/log(absolute)&lt;/li&gt;
&lt;li&gt;cd../var/log(relative)&lt;/li&gt;
&lt;li&gt;.: 代表当前的目录，也可以用./来表示&lt;/li&gt;
&lt;li&gt;..: 代表上一层目录，也可以用../来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;例子&lt;/h3&gt;

&lt;p&gt;将install.log文件复制成为LAYtest.log，并且要给linanya这个人读写权限，可以这样做：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[root@localhost ~]# cp install.log LAYtest.log     #若复制文件夹，用cp -r
[root@localhost ~]# ls -al LAYtest.log 
-rw-r--r-- 1 root root 62826 9月  17 15:19 LAYtest.log     #虽然完成了复制，但仍然是root的文件
[root@localhost ~]# chown linanya LAYtest.log 
[root@localhost ~]# ls -al LAYtest.log       
-rw-r--r-- 1 linanya root 62826 9月  17 15:19 LAYtest.log  #文件变成linanya的
[root@localhost ~]# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Markdown输入LaTeX数学公式</title>
        <link>http://eledata.github.io/2014/09/16/Markdown-Math.html</link>
        <guid isPermaLink="true">http://eledata.github.io/2014/09/16/Markdown-Math.html</guid>
        <pubDate>Tue, 16 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Markdown是读写性都非常好的轻量文本编辑语言，这个博客以及世界上许多博客的文章都是用其书写的。但是，在写“科研”博客时，难免会需要频繁地输入数学公式，而Markdown本身并不支持数学公式的输入。我曾经想偷懒直接用Markdown的语法去代替LaTeX数学公式，最后页面显示的结果有点儿丑。却一直也没有去修改。直到前天收到了&lt;a href=&quot;http://www.math.ucla.edu/%7Ewotaoyin/&quot;&gt;印卧涛&lt;/a&gt;老师的一封邮件，邮件里所有的数学公式都是用LaTeX代码写的，正规而美观。由此觉得自己做事还是水了点。做事要认真啊亲。&lt;/p&gt;

&lt;p&gt;本文默认我们是会使用LaTeX编辑数学公式的。&lt;/p&gt;

&lt;h3&gt;解决办法：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将数学公式以图片形式保存，再在Markdown中将其插入。&lt;/li&gt;
&lt;li&gt;或者，使用LaTeX在线编辑器，输入数学公式，获得html代码，将其插入Markdown。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;步骤：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.codecogs.com/latex/eqneditor.php&quot;&gt;CodeCogs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在盒子里书写公式&lt;/li&gt;
&lt;li&gt;在页面下方复制html代码&lt;/li&gt;
&lt;li&gt;将复制的html代码拷贝到Markdown里&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;缺点：&lt;/h3&gt;

&lt;p&gt;Markdown文件的易读性却因此下降了很多。&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>