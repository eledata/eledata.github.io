<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>林安亚的博客</title>
    <link>http://painterlin.com</link>
    <description>My personal blog</description>
    
      <item>
        <title>从二次型最优化问题中理解矩阵特征值的意义</title>
        <link>http://painterlin.com/2015/09/12/Intuition-of-Eigen-Value.html</link>
        <guid isPermaLink="true">http://painterlin.com/2015/09/12/Intuition-of-Eigen-Value.html</guid>
        <pubDate>Sat, 12 Sep 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;惯例开场故事&lt;/h3&gt;

&lt;p&gt;在某次从实验室去往食堂的路上，曾发生这样一段对话：&lt;/p&gt;

&lt;p&gt;『大师兄，为什么你对算法的理解总是那么透彻呢？为什么我很难看出它背后的思想？』&lt;/p&gt;

&lt;p&gt;『因为你去理解一个算法的时候，不能只是看懂它的形，还要去思考它的神啊~』&lt;/p&gt;

&lt;p&gt;这就是我天分不够当不了科学家的佐证吧T。T&lt;/p&gt;

&lt;h3&gt;从二次型最优化来理解&lt;/h3&gt;

&lt;p&gt;最小化二次型目标函数&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=x^TAx&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=x^TAx&quot; title=&quot;f(x)=x^TAx&quot; /&gt;&lt;/a&gt;，其中A为已知的实对称二阶矩阵，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=A=[1,0.5;0.5,1]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?A=[1,0.5;0.5,1]&quot; title=&quot;A=[1,0.5;0.5,1]&quot; /&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x=[x_1,x_2]^{\textrm{T}}&amp;space;\in&amp;space;\textcal{R}^2&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x=[x_1,x_2]^{\textrm{T}}&amp;space;\in&amp;space;\textcal{R}^2&quot; title=&quot;x=[x_1,x_2]^{\textrm{T}} \in \textcal{R}^2&quot; /&gt;&lt;/a&gt;.这个问题的求解很简单，这里以此为例来说明该问题与矩阵特征值的关系。&lt;/p&gt;

&lt;p&gt;首先，可以得到目标函数的网格图与等高线图如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/mesh_of_f.png&quot; alt=&quot;1&quot;&gt;
&lt;img src=&quot;/public/img/posts/contour_of_f.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;p&gt;对矩阵A进行特征分解可以得到其特征向量为[-0.7071, 0.7071], [0.7071, 0.7071]，对应的特征值分别是0.5, 1.5.&lt;/p&gt;

&lt;p&gt;观察函数的等高线图可以知道，等高线最密集的地方，函数值变化最快，而这个函数值变化最快的方向归一化后就是[0.7071, 0.7071]，这恰好是矩阵的一个特征向量。同样地，可以观察，等高线最稀疏的地方，函数值变化最慢，变化方向则是矩阵的另一个特征向量。可以看出，&lt;code&gt;矩阵特征值的大小与函数值的变化快慢有关&lt;/code&gt;，较大特征值所对应的特征向量方向上函数值的变化较快，较小特征值所对应的特征向量方向上函数值的变化较慢。&lt;/p&gt;

&lt;p&gt;进一步，对于实对称矩阵，我们总是可以对其进行相似变化，得到一个以该矩阵特征值为对角线元素的对角阵。&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=P^{-1}AP=B&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?P^{-1}AP=B&quot; title=&quot;P^{-1}AP=B&quot; /&gt;&lt;/a&gt;，其中，P为正交矩阵，有性质P的逆等于P的转置。把目标函数改写为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; title=&quot;f(x)=x^{\textrm{T}}PBP^{\textrm{T}}x&quot; /&gt;&lt;/a&gt;，其中&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=B=[0.5,&amp;space;0;&amp;space;0,&amp;space;1.5]&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?B=[0.5,&amp;space;0;&amp;space;0,&amp;space;1.5]&quot; title=&quot;B=[0.5, 0; 0, 1.5]&quot; /&gt;&lt;/a&gt;. 相似变换的作用可以理解为将等高线图进行旋转，于是得到下面经过旋转后的等高线图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/contour_of_f_B.png&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;p&gt;在这张图上说明矩阵特征值的意义。当函数值取1时所对应的椭圆等高线的长轴长度为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\frac{1}{\sqrt{0.5}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\frac{1}{\sqrt{0.5}}&quot; title=&quot;\frac{1}{\sqrt{0.5}}&quot; /&gt;&lt;/a&gt;， 即由矩阵特征值0.5决定。同理，该椭圆短轴长度为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\frac{1}{\sqrt{1.5}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\frac{1}{\sqrt{1.5}}&quot; title=&quot;\frac{1}{\sqrt{1.5}}&quot; /&gt;&lt;/a&gt;，由矩阵特征值1.5决定。&lt;/p&gt;

&lt;p&gt;二阶矩阵的理解较为直观。高阶矩阵的道理是一样的。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.zhihu.com/question/21874816/answer/19592526&quot;&gt;如何理解矩阵特征值&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）</title>
        <link>http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html</link>
        <guid isPermaLink="true">http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html</guid>
        <pubDate>Mon, 23 Mar 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最近做LBFGS的并行，顺便把牛顿法、拟牛顿法顺理一下。&lt;/p&gt;

&lt;p&gt;拟牛顿法是求解非线性优化问题最有效的方法之一。考虑无约束的极小化问题&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\min\limits_x&amp;space;f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\min\limits_x&amp;space;f(x)&quot; title=&quot;\min\limits_x f(x)&quot; /&gt;&lt;/a&gt;，假设&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)&quot; title=&quot;f(x)&quot; /&gt;&lt;/a&gt;为凸函数，且二阶连续可导。&lt;/p&gt;

&lt;h3&gt;原始牛顿法&lt;/h3&gt;

&lt;p&gt;基本思想：在现有极小点估计值的附近对f(x)进行二阶泰勒展开，进而找到下一个极小点的估计值&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{k&amp;plus;1}=x_{k}-(H_k)^{-1}g_{k},&amp;space;k=0,1,\cdots&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{k&amp;plus;1}=x_{k}-(H_k)^{-1}g_{k},&amp;space;k=0,1,\cdots&quot; title=&quot;x_{k+1}=x_{k}-(H_k)^{-1}g_{k}, k=0,1,\cdots&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;牛顿法具有二次收敛性，但当目标函数非二次型时，牛顿法不能保证函数稳定地下降（缺点）。&lt;/p&gt;

&lt;h3&gt;阻尼牛顿法&lt;/h3&gt;

&lt;p&gt;每次迭代前需要沿迭代方向&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=d_k=-(H_k)^{-1}g_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?d_k=-(H_k)^{-1}g_k&quot; title=&quot;d_k=-(H_k)^{-1}g_k&quot; /&gt;&lt;/a&gt;做线搜索，寻求最优的步长因子&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\lambda_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\lambda_k&quot; title=&quot;\lambda_k&quot; /&gt;&lt;/a&gt;，即&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\lambda_k&amp;space;=&amp;space;\arg\min\limits_{\lambda}&amp;space;f(x_k&amp;plus;\lambda&amp;space;d_k)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\lambda_k&amp;space;=&amp;space;\arg\min\limits_{\lambda}&amp;space;f(x_k&amp;plus;\lambda&amp;space;d_k)&quot; title=&quot;\lambda_k = \arg\min\limits_{\lambda} f(x_k+\lambda d_k)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;拟牛顿法&lt;/h3&gt;

&lt;p&gt;基本思想：不使用二阶偏导数而构造出可以近似Hession或Hession的逆的正定对称阵，在“拟牛顿”的条件下优化目标函数。&lt;/p&gt;

&lt;p&gt;先推导拟牛顿条件：在&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x_{k&amp;plus;1}&quot; title=&quot;x_{k+1}&quot; /&gt;&lt;/a&gt;附近对&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)&quot; title=&quot;f(x)&quot; /&gt;&lt;/a&gt;做泰勒展开，取二阶近似项&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=f(x)=f(x_{k&amp;plus;1})&amp;plus;\nabla&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&amp;plus;\frac{1}{2}(x-x_{k&amp;plus;1})^T\nabla^2&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?f(x)=f(x_{k&amp;plus;1})&amp;plus;\nabla&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&amp;plus;\frac{1}{2}(x-x_{k&amp;plus;1})^T\nabla^2&amp;space;f(x_{k&amp;plus;1})(x-x_{k&amp;plus;1})&quot; title=&quot;f(x)=f(x_{k+1})+\nabla f(x_{k+1})(x-x_{k+1})+\frac{1}{2}(x-x_{k+1})^T\nabla^2 f(x_{k+1})(x-x_{k+1})&quot; /&gt;&lt;/a&gt;
推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\nabla&amp;space;f(x)\approx&amp;space;\nabla&amp;space;f(x_{k&amp;plus;1})&amp;plus;H_{k&amp;plus;1}(x-x_{k&amp;plus;1})&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\nabla&amp;space;f(x)\approx&amp;space;\nabla&amp;space;f(x_{k&amp;plus;1})&amp;plus;H_{k&amp;plus;1}(x-x_{k&amp;plus;1})&quot; title=&quot;\nabla f(x)\approx \nabla f(x_{k+1})+H_{k+1}(x-x_{k+1})&quot; /&gt;&lt;/a&gt;
取&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x=x_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x=x_k&quot; title=&quot;x=x_k&quot; /&gt;&lt;/a&gt;，推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=g_{k&amp;plus;1}-g_{k}\approx&amp;space;H_{k&amp;plus;1}(x_{k&amp;plus;1}-x_k)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?g_{k&amp;plus;1}-g_{k}\approx&amp;space;H_{k&amp;plus;1}(x_{k&amp;plus;1}-x_k)&quot; title=&quot;g_{k+1}-g_{k}\approx H_{k+1}(x_{k+1}-x_k)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;引入记号 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=s_k=x_{k&amp;plus;1}-x_{k},&amp;space;y_k=g_{k&amp;plus;1}-g_{k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?s_k=x_{k&amp;plus;1}-x_{k},&amp;space;y_k=g_{k&amp;plus;1}-g_{k}&quot; title=&quot;s_k=x_{k+1}-x_{k}, y_k=g_{k+1}-g_{k}&quot; /&gt;&lt;/a&gt;， 推出&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=y_k=H_{k&amp;plus;1}s_k&amp;space;,&amp;space;s_k=H^{-1}_{k&amp;plus;1}y_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?y_k=H_{k&amp;plus;1}s_k&amp;space;,&amp;space;s_k=H^{-1}_{k&amp;plus;1}y_k&quot; title=&quot;y_k=H_{k+1}s_k , s_k=H^{-1}_{k+1}y_k&quot; /&gt;&lt;/a&gt;(&lt;code&gt;拟牛顿条件&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;它迭代过程中的hession矩阵做约束，因此，对hession对近似的&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=B_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?B_{k&amp;plus;1}&quot; title=&quot;B_{k+1}&quot; /&gt;&lt;/a&gt;，以及对hession的逆做近似的&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_{k&amp;plus;1}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_{k&amp;plus;1}&quot; title=&quot;D_{k+1}&quot; /&gt;&lt;/a&gt;，可以将&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=y_{k}=B_{k&amp;plus;1}s_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?y_{k}=B_{k&amp;plus;1}s_k&quot; title=&quot;y_{k}=B_{k+1}s_k&quot; /&gt;&lt;/a&gt; 或 &lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=s_{k}=D_{k&amp;plus;1}y_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?s_{k}=D_{k&amp;plus;1}y_k&quot; title=&quot;s_{k}=D_{k+1}y_k&quot; /&gt;&lt;/a&gt; 作为指导。&lt;/p&gt;

&lt;h4&gt;DFP算法（Davidon–Fletcher–Powell formula）&lt;/h4&gt;

&lt;p&gt;核心：通过迭代的方法，对hession的逆做近似。迭代格式为&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_{k&amp;plus;1}=D_k&amp;plus;\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_{k&amp;plus;1}=D_k&amp;plus;\Delta&amp;space;D_k&quot; title=&quot;D_{k+1}=D_k+\Delta D_k&quot; /&gt;&lt;/a&gt;（通常&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=D_0=I&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?D_0=I&quot; title=&quot;D_0=I&quot; /&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;猜想&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k&quot; title=&quot;\Delta D_k&quot; /&gt;&lt;/a&gt;待定为&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k=\alpha&amp;space;\mathbf{u}&amp;space;\mathbf{u}^{\mathrm{T}}&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k=\alpha&amp;space;\mathbf{u}&amp;space;\mathbf{u}^{\mathrm{T}}&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; title=&quot;\Delta D_k=\alpha \mathbf{u} \mathbf{u}^{\mathrm{T}}+\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}&quot; /&gt;&lt;/a&gt;（具有对称性）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;s_k=D_ky_k&amp;plus;\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k&amp;plus;(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}&amp;plus;(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;s_k=D_ky_k&amp;plus;\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k&amp;plus;\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k&amp;plus;(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}&amp;plus;(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; title=&quot;\Rightarrow s_k=D_ky_k+\alpha\mathbf{u}\mathbf{u}^{\mathrm{T}}y_k+\beta\mathbf{v}\mathbf{v}^{\mathrm{T}}y_k=D_ky_k+(\alpha\mathbf{u}^{\mathrm{T}}y_k)\mathbf{u}+(\beta\mathbf{v}^{\mathrm{T}}y_k)\mathbf{v}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;括号中是数值，将其分别简单赋值为1，-1，即&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; title=&quot;\alpha=\frac{1}{\mathbf{u}^{\mathrm{T}}y_k},\beta=-\frac{1}{\mathbf{v}^{\mathrm{T}}y_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中向量u,v仍有待确定，由上面&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; title=&quot;\Rightarrow \mathbf{u}-\mathbf{v}=s_k-D_ky_k&quot; /&gt;&lt;/a&gt;（要此式成立，不妨直接取&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; title=&quot;\mathbf{u}=s_k,\mathbf{v}=D_ky_k&quot; /&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; title=&quot;\Rightarrow \alpha=\frac{1}{s^{\mathrm{T}}_ky_k},\beta=-\frac{1}{y^{\mathrm{T}}_kD_ky_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;至此，校正矩阵&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Delta&amp;space;D_k&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Delta&amp;space;D_k&quot; title=&quot;\Delta D_k&quot; /&gt;&lt;/a&gt;就已经构造出来了&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\Rightarrow&amp;space;\Delta&amp;space;D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\Rightarrow&amp;space;\Delta&amp;space;D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; title=&quot;\Rightarrow \Delta D_k=\frac{s_ks_k^{\mathrm{T}}}{s_k^{\mathrm{T}}y_k}-\frac{D_ky_ky_k^{\mathrm{T}}D_k}{y_k^{\mathrm{T}}D_ky_k}&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;BFGS算法（Broyden–Fletcher–Goldfarb–Shanno algorithm）&lt;/h4&gt;

&lt;p&gt;核心公式的推导过程与DFP完全类似，只是互换了其中s{k}和y{k}的位置。BFGS直接逼近Hession矩阵B_k。(公式敲起来太累了，请自行推导)&lt;/p&gt;

&lt;h4&gt;LBFGS算法(limited-memory BFGS)&lt;/h4&gt;

&lt;p&gt;不再存储完整的D&lt;em&gt;k，而是存储计算过程中的向量序列{s}，{y}。当需要矩阵D&lt;/em&gt;k时，利用向量序列的计算来代替。并且，向量序列也不是全部存储，而是固定存最新的m个。&lt;/p&gt;

&lt;p&gt;若要实现并行，需要同时在x与梯度（影响y的计算）那儿求一致平均。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://en.wikipedia.org/wiki/Davidon%E2%80%93Fletcher%E2%80%93Powell_formula&quot;&gt;DFP算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;http://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm&quot;&gt;BFGS算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【3】&lt;a href=&quot;http://en.wikipedia.org/wiki/Limited-memory_BFGS&quot;&gt;LBFGS算法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【4】&lt;a href=&quot;http://papers.nips.cc/paper/5333-large-scale-l-bfgs-using-mapreduce.pdf&quot;&gt;Large-scale L-BFGS using MapReduce&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac以及Windows上搭建C++工作环境</title>
        <link>http://painterlin.com/2015/02/13/Cplus-on-MAC.html</link>
        <guid isPermaLink="true">http://painterlin.com/2015/02/13/Cplus-on-MAC.html</guid>
        <pubDate>Fri, 13 Feb 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;实验室里我申请的垃圾老爷机被师弟玩坏了，弄了一天，最后发现根本就是硬件损伤，想把它砸掉！太坑了。&lt;/p&gt;

&lt;p&gt;clang是osx自带的c,c++,objective-c编译器；gnu是常用的c++的轻量级编译器，在windows上通常是下载MinGW；sublime就不多说了；本文的目的就是搭建一个轻量级的C++编辑-编译-调试-运行环境。&lt;/p&gt;

&lt;h2&gt;MAC上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;打开sublime，&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入install，选择&lt;code&gt;install package&lt;/code&gt;，回车&lt;/li&gt;
&lt;li&gt;输入sublimeClang，回车下载&lt;/li&gt;
&lt;li&gt;编写一个简单的c++程序，保存为name.cpp&lt;/li&gt;
&lt;li&gt;在terminal中，&lt;code&gt;clang++ name.cpp -o name&lt;/code&gt;或者&lt;code&gt;g++ name.cpp -o name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;双击name运行&lt;/li&gt;
&lt;li&gt;如果运行过程不需要输入数据，可以直接在sublime中&lt;code&gt;command&lt;/code&gt;+&lt;code&gt;shift&lt;/code&gt;+&lt;code&gt;B&lt;/code&gt;运行&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;AppStore中下载Xcode&lt;/li&gt;
&lt;li&gt;使用这个IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;WINDOWS上&lt;/h2&gt;

&lt;h3&gt;方法一：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装Installation Manager，运行，选择需要下载的组件，比如这里需要C++有关的组件&lt;/li&gt;
&lt;li&gt;将MinGW的安装路径添加到环境变量中&lt;/li&gt;
&lt;li&gt;cmd中输入&lt;code&gt;g++ -v&lt;/code&gt;来检测gnu是否安装成功&lt;/li&gt;
&lt;li&gt;打开sublime text 3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;browse packages&lt;/code&gt;-&amp;gt;&lt;code&gt;gcc&lt;/code&gt;(好像是这样，反正自己摸索就好了)&lt;/li&gt;
&lt;li&gt;OK，完成&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;方法二：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Visual Studio&lt;/li&gt;
&lt;li&gt;使用该IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;有用的资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/g++/index.html&quot;&gt;Writing and Running C++ Programs in the UNIX Environment using g++&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;https://www.cs.drexel.edu/%7Emcs171/Sp14/extras/xCode_Instructions/index.html&quot;&gt;Writing and Running C++ Programs in the Mac OS X 10.4 Environment using xCode&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>大数据机器学习初探---南大李武军</title>
        <link>http://painterlin.com/2015/02/04/Group-Meeting.html</link>
        <guid isPermaLink="true">http://painterlin.com/2015/02/04/Group-Meeting.html</guid>
        <pubDate>Wed, 04 Feb 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;每周的组会大概会持续2小时。如果是主讲，就需要花更多的时间去准备报告内容。之前，组会开完我就不管了，缺乏总结思考。而这样子的话实质上意义就不大了，没有内化为自己的知识，也没有什么critical thinking。从现在开始，记录每一次组会的思考。&lt;/p&gt;

&lt;p&gt;常言道：亡羊补牢，为时未晚。T.T&lt;/p&gt;

&lt;h3&gt;Outline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Learning to Hash&lt;/li&gt;
&lt;li&gt;Distributed Learning&lt;/li&gt;
&lt;li&gt;Stochastic Learning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有一个形象的比喻是这样说的，大数据是金矿，云计算是采矿技术，大数据机器学习是冶金技术。&lt;/p&gt;

&lt;p&gt;大数据机器学习面临的挑战，一是存储，而是计算速度，三是网络。&lt;/p&gt;

&lt;p&gt;哈希学习，在内存、硬盘、cpu、通信上有优势；
分布式学习在内存、硬盘、cpu上有优势，但会增加通信成本；随机学习在内存、硬盘、cpu方面有优势。&lt;/p&gt;

&lt;h3&gt;Learning to Hash&lt;/h3&gt;

&lt;p&gt;主讲人：大师兄&lt;/p&gt;

&lt;p&gt;最近邻搜索在大数据背景下，会出现维数灾难，存储成本也高，查询速度也慢。解决方法之一是保相似性哈希，可以降低维数并减少存储成本。通常用海明距离（hamming distance）来表征哈希值之间的差异。哈希方案也具有较快的查询速度，通常具有常数或者次线性的搜索时间复杂度；即使是穷举搜索也可以被接受，因为海明距离计算起来是很快的。&lt;/p&gt;

&lt;p&gt;哈希函数学习的两个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Projection Stage（dimension reduction）&lt;/li&gt;
&lt;li&gt;Quantization Stage&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;贡献：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Isotropic Hash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思想：学习一个正交阵（幻灯片21页），其目的是让大于某一阈值的feature的重要程度是一样的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Supervised Hashing with Latent Factor Models&lt;/li&gt;
&lt;li&gt;Supervised Multimodal Hashing with SCM&lt;/li&gt;
&lt;li&gt;Multiple-Bit Quantization&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Distributed Learning&lt;/h3&gt;

&lt;p&gt;主讲人：我&lt;/p&gt;

&lt;p&gt;主要内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;文章：Coupled Group Lasso for Web-Scale CTR Prediction&lt;/li&gt;
&lt;li&gt;文章：Distributed Power-Law Graph Computing&lt;/li&gt;
&lt;/ol&gt;

&lt;h4&gt;文章1&lt;/h4&gt;

&lt;p&gt;为了解决在线广告的CTR（click through rate）预测，即当某广告展示给某用户时，它被该用户点击的概率，通常的方法是LR（logistic regression），即逻辑回归。但LR的一个短板是，因其是线性的，所以无法将用户与广告之间某些微妙的非线性关系纳入。注意LR中，正则项若为2范数平方，称为标准逻辑回归；正则项若为1范数，问题通常被叫做Lasso。所以需要一种新的方法。&lt;/p&gt;

&lt;p&gt;这里的贡献是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CGL的似然定义中，可以纳入用户与广告之间的某些非线性关系的考量。&lt;/li&gt;
&lt;li&gt;正则项改为参数的2-1范数，目的是是用户特征向量参数W、广告特征向量参数V中更多的行为0，行为0说明该行对应的feature没作用，即达到删除冗余feature的作用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分布式实现。这个算法具有较好的扩展性，一个master，若干slave，类似于并行计算，从而实现分布式。&lt;/p&gt;

&lt;h4&gt;文章2&lt;/h4&gt;

&lt;p&gt;GP（graph partitioning）图分割的方法有两种：边分割；点分割。点分割在分布式计算中的通信成本会比图分割小，原因在于在不同的machine上，点分割只需保留点的copy，而边分割需要同时保留点与边的copy。&lt;/p&gt;

&lt;p&gt;切割degree大的点，即邻居多的点可以降低通信成本。&lt;/p&gt;

&lt;h3&gt;Stochastic Learning&lt;/h3&gt;

&lt;p&gt;主讲人：浩锋&lt;/p&gt;

&lt;p&gt;思想：在需要用到所有节点上的信息时，通信代价往往很大，这时可以随机的选取某一个节点上的信息（比如梯度）作为替代品。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://cs.nju.edu.cn/lwj/slides/BigLearning.pdf&quot;&gt;幻灯片&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【2】&lt;a href=&quot;http://jmlr.csail.mit.edu/proceedings/papers/v32/yan14.pdf&quot;&gt;Coupled Group Lasso for
Web-Scale CTR Prediction in Display Advertising&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;【3】&lt;a href=&quot;http://papers.nips.cc/paper/5396-distributed-power-law-graph-computing-theoretical-and-empirical-analysis.pdf&quot;&gt;Distributed Power-law Graph Computing:
Theoretical and Empirical Analysis&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Git常用命令速查表</title>
        <link>http://painterlin.com/2015/01/30/Git-Resources.html</link>
        <guid isPermaLink="true">http://painterlin.com/2015/01/30/Git-Resources.html</guid>
        <pubDate>Fri, 30 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;master: 默认开发分支&lt;/p&gt;

&lt;p&gt;origin: 默认远程版本库&lt;/p&gt;

&lt;p&gt;Head: 默认开发分支&lt;/p&gt;

&lt;p&gt;Head^: Head的父提交&lt;/p&gt;

&lt;h3&gt;创建版本库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git clone &amp;lt;url&amp;gt;   #克隆远程版本库
$ git init          #初始化本地版本库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改和提交&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git status        #查看状态
$ git diff          #查看变更内容
$ git add .         #跟踪所有改动过的文件
$ git add &amp;lt;file&amp;gt;    #跟踪指定的文件
$ git mv &amp;lt;old&amp;gt;&amp;lt;new&amp;gt; #文件改名
$ git rm&amp;lt;file&amp;gt;      #删除文件
$ git rm --cached&amp;lt;file&amp;gt;            #停止跟踪文件但不删除
$ git commit -m &amp;quot;commit messages&amp;quot;  #提交所有更新过的文件
$ git commit --amend               #修改最后一次改动
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;查看提交历史&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git log                    #查看提交历史
$ git log -p &amp;lt;file&amp;gt;          #查看指定文件的提交历史
$ git blame &amp;lt;file&amp;gt;           #以列表方式查看指定文件的提交历史
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;撤销&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git reset --hard HEAD      #撤销工作目录中所有未提交文件的修改内容
$ git checkout HEAD &amp;lt;file&amp;gt;   #撤销指定的未提交文件的修改内容
$ git revert &amp;lt;commit&amp;gt;        #撤销指定的提交
$ git log --before=&amp;quot;1 days&amp;quot;  #退回到之前1天的版本 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;分支与标签&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git branch                   #显示所有本地分支
$ git checkout &amp;lt;branch/tag&amp;gt;    #切换到指定分支和标签
$ git branch &amp;lt;new-branch&amp;gt;      #创建新分支
$ git branch -d &amp;lt;branch&amp;gt;       #删除本地分支
$ git tag                      #列出所有本地标签
$ git tag &amp;lt;tagname&amp;gt;            #基于最新提交创建标签
$ git tag -d &amp;lt;tagname&amp;gt;         #删除标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;合并与衍合&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git merge &amp;lt;branch&amp;gt;        #合并指定分支到当前分支
$ git rebase &amp;lt;branch&amp;gt;       #衍合指定分支到当前分支
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;远程操作&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ git remote -v                   #查看远程版本库信息
$ git remote show &amp;lt;remote&amp;gt;        #查看指定远程版本库信息
$ git remote add &amp;lt;remote&amp;gt; &amp;lt;url&amp;gt;   #添加远程版本库
$ git fetch &amp;lt;remote&amp;gt;              #从远程库获取代码
$ git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #下载代码及快速合并
$ git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;      #上传代码及快速合并
$ git push &amp;lt;remote&amp;gt; :&amp;lt;branch/tag-name&amp;gt;  #删除远程分支或标签
$ git push --tags                       #上传所有标签
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;资料链接&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://try.github.io/levels/1/challenges/1&quot;&gt;Try Git&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>2015年阅读书单</title>
        <link>http://painterlin.com/2015/01/29/Book-List-2015.html</link>
        <guid isPermaLink="true">http://painterlin.com/2015/01/29/Book-List-2015.html</guid>
        <pubDate>Thu, 29 Jan 2015 00:00:00 +0800</pubDate>
        <description></description>
      </item>
    
      <item>
        <title>在Mac上用LaTeX写漂亮的简历</title>
        <link>http://painterlin.com/2014/12/06/Make-resume-by-LaTeX.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/12/06/Make-resume-by-LaTeX.html</guid>
        <pubDate>Sat, 06 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/resume.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;p&gt;你会搜索查看到这篇文章，相信就不需要我解释为什么要用LaTeX写Resume了：）&lt;/p&gt;

&lt;p&gt;今晚报名Facebook China Tech Talk，最后一步需要上传简历。看着已经2年没有更新过的简历，好捉急。那时真是年轻，不舍得做减法，恨不能一张A4纸写尽一生。于是索性重新制作一份简历。&lt;/p&gt;

&lt;h3&gt;需要准备&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装好的LaTeX，如果没有安装请参考&lt;a href=&quot;http://painterlin.com/2014/08/10/Using-LaTeX-with-Sublime-and-Skim-for-Mac.html&quot;&gt;在Mac上通过Sublime、Skim编辑LaTeX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;互联网&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rpi.edu/dept/arc/training/latex/resumes/&quot;&gt;Using the LaTeX Resume Templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.latextemplates.com/cat/curricula-vitae&quot;&gt;LaTeX Templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在上述资料中寻找自己喜欢的模板&lt;/li&gt;
&lt;li&gt;下载模板对应的tex文件&lt;/li&gt;
&lt;li&gt;用LaTeX打开对应文件，编辑，编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候，如果你使用的是Mac系统，非常不幸，大多数情况下都将编译失败。因为网上多数模板需要使用windows环境下的Tex应用程序，而Mac环境下MacTex应用程序会缺少部分文件。没关系，我们有办法解决。&lt;/p&gt;

&lt;h3&gt;解决方案一：moderncv&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.ctan.org/pkg/moderncv&quot;&gt;http://www.ctan.org/pkg/moderncv &lt;/a&gt;下载&lt;code&gt;moderncv package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解压，找到模板文件&lt;code&gt;template.tex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用已经安装好的LaTeX打开模板文件，编辑，编译，成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是呢，我个人觉得moderncv模板并不够好，虽然其结构清新简洁，但布局过于稀疏。没关系，我们仍然有办法。感谢一个我无意中发现的网站：ShareLaTeX.com&lt;/p&gt;

&lt;h3&gt;解决方案二：ShareLaTeX.com&lt;/h3&gt;

&lt;p&gt;也许你在上面的资料中找到了你最喜欢的模板，却苦于在Mac OS X系统下无法编译成功。这时可以求助于&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，这是一个在线LaTeX编辑网站，并且提供&lt;code&gt;Resume&lt;/code&gt;,&lt;code&gt;Cover Letter&lt;/code&gt;,&lt;code&gt;Journal Article&lt;/code&gt;,&lt;code&gt;Presentation&lt;/code&gt;,&lt;code&gt;Thesis&lt;/code&gt;,&lt;code&gt;Bibliographies&lt;/code&gt;等不同分类的多种模板。最重要的一点事，只需要确定Latex语法无误，再也不需担心什么编译环境、文件缺失等乱七八糟的问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进入&lt;a href=&quot;https://www.sharelatex.com/&quot;&gt;ShareLaTeX&lt;/a&gt;，注册账号&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;New Project&lt;/code&gt;，选择&lt;code&gt;CV or Resume&lt;/code&gt;，挑选你喜欢的简历模板&lt;/li&gt;
&lt;li&gt;根据自己的情况编辑，自动或手动编译，保存PDF&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;既然写到这里了，还想讲讲自己对于简历的体会。但我真的是困得不行了。。。。北京第一次不归夜。。。改天再来补全。。。。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>我的报告 Decentralized Privacy-Preserving Low-Rank Matrix Completion</title>
        <link>http://painterlin.com/2014/11/26/Presentation-at-Chinese-Academy-of-Science.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/11/26/Presentation-at-Chinese-Academy-of-Science.html</guid>
        <pubDate>Wed, 26 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;/public/img/posts/s1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;我的报告&lt;/h3&gt;

&lt;h4&gt;Section 0: Introduce Myself&lt;/h4&gt;

&lt;p&gt;Page 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Good afternoon everyone! My name is Anya Lin. I&amp;#39;m a second-year master candidate from University of Science and Technology of China. It&amp;#39;s my great pleasure to introduce to you the Decentralized Privacy-Preserving Low-Rank Matrix Completion. It&amp;#39;s a joint work with my supervisor, Prof. Ling from USTC.&lt;/li&gt;
&lt;li&gt;Before I start, I want to express my thanks to Prof. Ling for his patient instructions and help over the last a few months.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 2&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Here&amp;#39;s the outline of my presentation.&lt;/li&gt;
&lt;li&gt;First is the introduction.&lt;/li&gt;
&lt;li&gt;And then the centralized matrix completion problem.&lt;/li&gt;
&lt;li&gt;We develop a decentralized algorithm in section 3, and our algorithm is derived from a centralized algorithm as I will talk about in section 2.&lt;/li&gt;
&lt;li&gt;Next, I will introduce the main result of the topology-dependent privacy preservation.&lt;/li&gt;
&lt;li&gt;At last, it&amp;#39;s the conclusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 1: Introduction&lt;/h4&gt;

&lt;p&gt;Page 3&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OK， let&amp;#39;s go into the introduction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 4&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;#39;d like to begin with the concept of matrix completion. So what is matrix completion? As we can see in this picture, we have an incomplete matrix, whose entries are known only for a subset of the whole matrix. And the rank of the matrix is very small compared with the size of the matrix.&lt;/li&gt;
&lt;li&gt;The goal of the matrix completion is to recover all these unknown entries of of the matrix, as the right-side picture shows. Here, Z is the recovery of W.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 5&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;There&amp;#39;s many applications of such a problem. Like image processing, recommendation system and so on. Here are 2 examples. The first one is a problem of image processing. The left picture has a lot of noises, or say, only a part of the original picture is known. By using the fact that the original picture is usually low-rank, we can matrix completion to denoise the picture and get a clear version of high quality as the right picture shows.&lt;/li&gt;
&lt;li&gt;The second example is more close to our lives. It&amp;#39;s related to a recommendation system. As you can see, it&amp;#39;s a webpage of Douban Movie. A user sees a movie, such as Interstella, and then scores it on the website. Here we can imagine a huge matrix with rows representing users and columns the movies. This matrix is incomplete and it&amp;#39;s low-rank. Once this matrix is completed, the website can recommend new movies to users.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 6&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now, here comes a privacy concern. First what is privacy? Privacy is the values one considers private. In the example we mentioned just now, the users&amp;#39; scores of the movies are privacy, because one may not want others to know what movies he has seen or likes. Also, the entries of the matrix could be medical records of patients, or selling data of merchants. These data are considered as privacy.&lt;/li&gt;
&lt;li&gt;Obviously, no one wants the leakage of his privacy.&lt;/li&gt;
&lt;li&gt;However, in reality there may exist a malicious agent, a bad guy. For some reasons you have to give your private data to it, but you don&amp;#39;t know wether you can trust it or not.&lt;/li&gt;
&lt;li&gt;In this situation, we need privacy-preservation. Privacy-preservation is the ability to prevent a malicious agent from obtaining or reconstructing the private data.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 2: Centralized Matrix Completion Problem&lt;/h4&gt;

&lt;p&gt;Page 7&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;#39;s go into the centralized matrix completion problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 8&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When we are faced with a low-rank matrix completion problem, the intuitive thought would be to minimize the rank of the matrix, but this is a nonconvex problem. &lt;/li&gt;
&lt;li&gt;Therefore, we insteadly minimize the nuclear-norm the the matrix, since nuclear-norm is the approximation of the rank and it&amp;#39;s convex.&lt;/li&gt;
&lt;li&gt;Another approach is if the rank of matrix is known to be r as a prior theoreticallyor empirically, we can get the matrix factorization formulation. This approach is advantageous over the nuclear-norm approach since the latter one needs sigular value decomposition, which is computationally expensive and even intractable in decentralized computing.&lt;/li&gt;
&lt;li&gt;A centralized algorithm called LMaFit to solve this is as the following steps shows.&lt;/li&gt;
&lt;li&gt;We have to keep in mind that our algorithm is derived from LMaFit.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 3: Decentralized Matrix Completion Problem&lt;/h4&gt;

&lt;p&gt;Page 9&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;After the centralized problem, let&amp;#39;s go into the decentralized one.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 10&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In decentralized computing, we have a network composed of L agents.&lt;/li&gt;
&lt;li&gt;There is an undirected edge between two agents if they can communicate with each other through one hop.&lt;/li&gt;
&lt;li&gt;The goal of all the agents in such a network is to collaboratively complete a low-rank matrix in a decentralized fashion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 11&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To be specific, we segment the whole data matrix W into groups of columns. And do the same to Y and Z. Each agent i in the network holds the corresponding Zi, Yi and entries of Wi. &lt;/li&gt;
&lt;li&gt;However, X cannot be segmented and distributed to agents because the update of X contains the summation of ZiYi&amp;#39; over all agents. So we let each agent i holds a local copy X(i) of X.&lt;/li&gt;
&lt;li&gt;After doing this, we get a naive decentralized implementation of LMaFit. At iteration k, each agent i does the following steps respectively.&lt;/li&gt;
&lt;li&gt;Notice that the update of X requires information aggregation of all agents. So here is the challenge: informationaggregationofallagentsisimpossible in real decentralized network unless every agent is connected to all the other agents. &lt;/li&gt;
&lt;li&gt;How to deal with this challenge?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 12&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The answer is dynamic average consensus. Recall that each agent i holds a local copy X(i) of X. If we can make sure that X(i) equals to X for all i, the challenge is solved. &lt;/li&gt;
&lt;li&gt;To do this, we choose c to be 1/L and the update of X becomes the average consensus problem, as we can see in equation (8), X(i) is the average of all the ZiYi&amp;#39;.&lt;/li&gt;
&lt;li&gt;At iteration k,we formulate the average consensus problem as equation (9). The constraint means that instead of letting all the X(i) to be identical we choose to let each X(i) equals to it neighboring X(j).&lt;/li&gt;
&lt;li&gt;A key observation is that exact average consensus at every iteration is not necessary. We use EXTRA to do inexact dynamic average consensus, which saves the computational cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 13&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Our decentralized algorithm called D-LMaFit is developed as below.&lt;/li&gt;
&lt;li&gt;Step 1 is the initialization.&lt;/li&gt;
&lt;li&gt;Step 2, use EXTRA to do the inexact average consensus problem.&lt;/li&gt;
&lt;li&gt;Step 3, update Y and X respectively. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 14&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The performance of D-LMaFit is shown in these two pictures. (Explain what these pictures indicate to the audience)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 4: Topology-Dependent Privacy Preservation&lt;/h4&gt;

&lt;p&gt;Page 15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now let&amp;#39;s go into the section of the topology-dependent privacy preservation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 16&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First compare decentralized algorithm with centralized one.&lt;/li&gt;
&lt;li&gt;Centralized algorithm needs a fusion center to collect global data. What if the fusion center is a malicious agent?&lt;/li&gt;
&lt;li&gt;Oops TT, you&amp;#39;ll lose all your privacy.&lt;/li&gt;
&lt;li&gt;How about the decentralzied algorithm? One important advantage of decentralized algortihm over a centralized is there&amp;#39;s no global data collection, each agent observes part of the raw data and communicates with its neighboring agent(s). It seems safer.&lt;/li&gt;
&lt;li&gt;But things aren&amp;#39;t so lucky in reality. Because the communication of X(i) among the network may lead to information leakage.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 17&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How does this happen? Suppose in a network as this picture shows, we have a malicious agent M, and M attempts to recover the local data matrices of some other agents through information exchange.&lt;/li&gt;
&lt;li&gt;M is interested in recovering the local data Wi, or equivalently Yi or Zi of a set of agents i∈I.&lt;/li&gt;
&lt;li&gt;When the iteration k is large enough, X(i) will be identical. So if a malicious agent M somehow knows other agents&amp;#39; Yi, it can recover the data Zi of agent i by doing X(M)Yi.&lt;/li&gt;
&lt;li&gt;So our concern is, is there any possibility that the malicious agent M can somehow obtain Yi of agent i, and thus get Zi, which is private.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 18&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Before going to details, consider two simple topologies.&lt;/li&gt;
&lt;li&gt;(Explain the two topologies)&lt;/li&gt;
&lt;li&gt;Under what conditions can not a malicious agent M reconstruct the sensitive information of P and Q ?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 19&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Recall the update of X.&lt;/li&gt;
&lt;li&gt;If you could just take a look at the equation, you can find that if the topology is as in the left picture, M can reconstruct ZiYi&amp;#39; and it may be able to solve Yi so that gets the privacy of P and Q.&lt;/li&gt;
&lt;li&gt;But if the topology is as shown in the right picture. M cannot get the private data of P and Q. Why?&lt;/li&gt;
&lt;li&gt;(Explain with the equation)&lt;/li&gt;
&lt;li&gt;M can solve a series of linear inverse problems and calculate the values of ZiYi&amp;#39;, as what we have said just now.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 20&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Now we get a naive conclusion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 21&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;So the privacy-preserving problem boils down to the linear inverse problem. First we define some variables as this.&lt;/li&gt;
&lt;li&gt;And further we define A and B.&lt;/li&gt;
&lt;li&gt;Using these definition,the update of X can be represented by (14).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 22&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rewrite this as a linear time-invariant systems we get (15). In this system, QI selects those row blocks in Q belonging to the agents in I, and BI selects the corresponding columns in B. QIC and BIC selects the other corresponding row blocks and columns which do not belong to the agents in I.&lt;/li&gt;
&lt;li&gt;Our analysis uses the concept of z-transfer matrix of (15). The concept is from modern control theory.&lt;/li&gt;
&lt;li&gt;Obviously, rank(T)=rank(TI TIC), since the latter matrix is just a column rearrangement of the former one. &lt;/li&gt;
&lt;li&gt;Now we are ready to develop our theorem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 23&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Check the proof of the suffienciency of our theorem, it&amp;#39;s rather straightforward.&lt;/li&gt;
&lt;li&gt;If this condition is satisfired, then M has full knowledge of all the X(i).&lt;/li&gt;
&lt;li&gt;So M can solve a series of linear inverse problems.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 24&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The proof of necessity is a little bit complicated. Here&amp;#39;s the only the simplified version of the proof.&lt;/li&gt;
&lt;li&gt; First we show that to determine a unique sequence of Q􏰇 from V􏰇 , we must have (18).&lt;/li&gt;
&lt;li&gt;Suppose (18) doesn&amp;#39;t hold, then there exists at least one column of TI that is linearly dependent on the other columns of T. Then there exists a Q with that column nonzero, and satisfies TQ=0. This corresponds to a nonzero input in I, but the output V is zero for all time. Thus this nonzero input cannot be recovered. This contradicts with the hypothesis. So (18) must hold.&lt;/li&gt;
&lt;li&gt;(Explain these items)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 25&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(Explain these items)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Section 5: Conclusion&lt;/h4&gt;

&lt;p&gt;Page 26&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;#39;d like to quickly go over the main point of today&amp;#39;s topic.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 27&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First, we propose a decentralized privacy-preserving algorithm, D-LMaFit, to solve the matrix completion problem.&lt;/li&gt;
&lt;li&gt;We solve dynamic average consensus subproblem inexactly.&lt;/li&gt;
&lt;li&gt;We prove the topology-dependent privacy-preserving theorem. It provides a guideline of designing a privacy-preserving network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 28&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Still we&amp;#39;ve got work to do in the future. (Read items)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Page 29&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I guess that&amp;#39;s it. Thank you all very much for listening. Now if you have any question, please feel free to ask me.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;故事&lt;/h3&gt;

&lt;p&gt;这学期我在中科院数学与系统科学研究院(AMSS)访问。第一次参与这边的讨论班时，我就被惊到了：学生做报告也全程英文，不愧是&lt;a href=&quot;http://lsec.cc.ac.cn/%7Eyyx/chinese/indexc.htm&quot;&gt;袁亚湘&lt;/a&gt;老师的学生。于是，11月25日，我也在这儿完成了自己第一次的英文学术报告。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;报告前3天，我问盛镇醴师兄他们报告前会不会排练，师兄说：“肯定要啊！上次去葡萄牙开会，&lt;a href=&quot;http://www.se.cuhk.edu.hk/people/sqma.html&quot;&gt;马士谦&lt;/a&gt;师兄已经讲得那么好了，都还又自己私下练习了5、6遍。师兄真的可以做到每句话精确到几秒钟！”太荔枝了有木有TT。&lt;/li&gt;
&lt;li&gt;于是我也练习了。果然只有努力了内心才会踏实。在当天的报告中，我不仅不紧张，还在瞅到台下一堆人的专注神情时，心里突然弹幕全开：“哇，这感觉好爽。”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在记录报告之前，插播一段回忆：
大三暑假，我参加&lt;a href=&quot;http://china.ican-contest.org/index.html&quot;&gt;中国大学生物联网创新创业大赛&lt;/a&gt;，正式比赛前一天系里组织答辩练习，我们组讲得一塌糊涂。那一晚，我和向国菲师兄在实验室通宵改幻灯片，准备发言稿，然后一句一句地练习。中途师兄压力太大又累得不行溜出去躲着抽了根烟，回来被我发现了教育了一顿，嗅觉就是这么灵敏没办法。直到凌晨4点，终于觉得还算满意了，两人躺椅子上睡了会儿，当然我被蚊子咬安逸了。早晨7点，寝室开门，两人各自回去洗澡调整状态。9点，开始比赛。不知道为什么突然想起这个，太，美好了。尽管当时觉得真苦逼。&lt;/p&gt;

&lt;h3&gt;资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.zhihu.com/question/24544386/answer/30237316&quot;&gt;有哪些高级的英语表达技巧，让人一听就很地道？&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>凸优化的一些基础算法</title>
        <link>http://painterlin.com/2014/11/10/Basic-Algorithms-of-Convex-Opt.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/11/10/Basic-Algorithms-of-Convex-Opt.html</guid>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;本文假设读者对凸优化有基本了解，主要归纳一些基础算法，以便查阅。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=\min&amp;space;f(x)&amp;space;\triangleq&amp;space;g(x)&amp;plus;h(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?\min&amp;space;f(x)&amp;space;\triangleq&amp;space;g(x)&amp;plus;h(x)&quot; title=&quot;\min f(x) \triangleq g(x)+h(x)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中，f，g，h都是凸函数，g是光滑项，h是非光滑项。&lt;/p&gt;

&lt;h3&gt;Gradient Descent&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&amp;plus;=x-\alpha\nabla&amp;space;f(x)&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&amp;plus;=x-\alpha\nabla&amp;space;f(x)&quot; title=&quot;x^+=x-\alpha\nabla f(x)&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Proximal Gradient&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=x^&amp;plus;=prox_{\alpha&amp;space;h}(x-\alpha&amp;space;\nabla&amp;space;g(x))=&amp;space;\arg\min_u&amp;space;h(u)&amp;plus;\frac{1}{2\alpha}||u-x&amp;plus;\alpha&amp;space;\nabla&amp;space;g(x)||&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?x^&amp;plus;=prox_{\alpha&amp;space;h}(x-\alpha&amp;space;\nabla&amp;space;g(x))=&amp;space;\arg\min_u&amp;space;h(u)&amp;plus;\frac{1}{2\alpha}||u-x&amp;plus;\alpha&amp;space;\nabla&amp;space;g(x)||&quot; title=&quot;x^+=prox_{\alpha h}(x-\alpha \nabla g(x))= \arg\min_u h(u)+\frac{1}{2\alpha}||u-x+\alpha \nabla g(x)||&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Conjugate Gradient&lt;/h3&gt;

&lt;p&gt;是介于最速下降法和牛顿法之间的一个方法，它仅需要利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hession并求逆的缺点。它是解决大型线性方程组最有用的方法之一，也是解决大型非线性最优化最有效的算法之一。&lt;/p&gt;

&lt;h3&gt;Newton&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html&quot;&gt;牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Quasi Newton&lt;/h3&gt;

&lt;p&gt;见&lt;a href=&quot;http://painterlin.com/2015/03/23/Newton-QuasiNewton-Method.html&quot;&gt;牛顿法与拟牛顿法（DFP BFGS LBFGS VLBFGS）&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>什么是 P, NP, NP-complete, NP-hard</title>
        <link>http://painterlin.com/2014/11/09/What-is-NP-Hard.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/11/09/What-is-NP-Hard.html</guid>
        <pubDate>Sun, 09 Nov 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;相关概念&lt;/h3&gt;

&lt;p&gt;NP-hard（non-deterministic polynomial-time hard）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;P：能在多项式时间内解决&lt;/li&gt;
&lt;li&gt;NP：不能在多项式时间内解决或不确定能不能在多项式时间内解决，但一旦你找到一个解，只需要多项式时间去验证这个解是正确的&lt;/li&gt;
&lt;li&gt;NP-hard：如果一个问题是NP-hard，意味着可以将任意NP问题化约到这个问题。如果可以解这个问题，那么可以轻松地解任意NP问题。&lt;/li&gt;
&lt;li&gt;NPC：NP完全问题，所有NP问题在多项式时间内都能化约（Reducibility）到某一NP问题，这一NP问题就是NPC问题，即解决了此NPC问题，所有NP问题也都解决了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;资料原文&lt;/h3&gt;

&lt;p&gt;These refer to how long it takes a program to run.  Problems in class P can be solved with algorithms that run in &lt;strong&gt;polynomial time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Say you have an algorithm that finds the smallest integer in an array.  One way to do this is by iterating over all the integers of the array and keeping track of the smallest number you&amp;#39;ve seen up to that point.  Every time you look at an element, you compare it to the current minimum, and if it&amp;#39;s smaller, you update the minimum.&lt;/p&gt;

&lt;p&gt;How long does this take?  Let&amp;#39;s say there are n elements in the array.  For every element the algorithm has to perform a constant number of operations.  Therefore we can say that the algorithm runs in O(n) time, or that the runtime is a linear function of how many elements are in the array.  So this algorithm runs in &lt;strong&gt;linear time&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You can also have algorithms that run in &lt;strong&gt;quadratic time&lt;/strong&gt; (O(n^2)), &lt;strong&gt;exponential time&lt;/strong&gt; (O(2^n)), or even &lt;strong&gt;logarithmic time&lt;/strong&gt; (O(log n)).  Binary search (on a balanced tree) runs in logarithmic time because the height of the binary search tree is a logarithmic function of the number of elements in the tree.&lt;/p&gt;

&lt;p&gt;If the running time is some polynomial function of the size of the input, for instance if the algorithm runs in linear time or quadratic time or cubic time, then we say the algorithm runs in &lt;strong&gt;polynomial time&lt;/strong&gt; and the problem it solves is in class &lt;strong&gt;P&lt;/strong&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Now there are a lot of programs that don&amp;#39;t (necessarily) run in polynomial time on a regular computer, but do run in polynomial time on a nondeterministic Turing machine.  These programs solve problems in &lt;strong&gt;NP&lt;/strong&gt;, which stands for &lt;strong&gt;nondeterministic polynomial time&lt;/strong&gt;.  A nondeterministic Turing machine can do everything a regular computer can and more. This means all problems in P are also in NP.&lt;/p&gt;

&lt;p&gt;An equivalent way to define NP is by pointing to the problems that can be verified in polynomial time.  This means there is not necessarily a polynomial-time way to find a solution, but once you have a solution it only takes polynomial time to verify that it is correct.&lt;/p&gt;

&lt;p&gt;Some people think P = NP, which means any problem that can be verified in polynomial time can also be solved in polynomial time and vice versa.  If they could prove this, it would revolutionize computer science because people would be able to construct faster algorithms for a lot of important problems.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP-hard&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;What does NP-hard mean?  A lot of times you can solve a problem by reducing it to a different problem.  I can reduce Problem B to Problem A if, given a solution to Problem A, I can easily construct a solution to Problem B.  (In this case, &amp;quot;easily&amp;quot; means &amp;quot;in polynomial time.&amp;quot;)&lt;/p&gt;

&lt;p&gt;If a problem is &lt;strong&gt;NP-hard&lt;/strong&gt;, this means I can reduce any problem in NP to that problem.  This means if I can solve that problem, I can easily solve any problem in NP.  If we could solve an NP-hard problem in polynomial time, this would prove P = NP.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;NP-complete&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;A problem is &lt;strong&gt;NP-complete&lt;/strong&gt; if the problem is both&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NP-hard, and&lt;/li&gt;
&lt;li&gt;in NP.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;【1】&lt;a href=&quot;http://www.quora.com/What-are-P-NP-NP-complete-and-NP-hard&quot;&gt;What are P, NP, NP-complete, and NP-hard?&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Yosemite OS X 10.10 Matlab 2012a停止工作的解决办法</title>
        <link>http://painterlin.com/2014/10/31/Yosemite-Matlab-Running-Error.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/10/31/Yosemite-Matlab-Running-Error.html</guid>
        <pubDate>Fri, 31 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;OS X 系统更新到Yosemite后，Matlab 2012a就无法运行了。&lt;/p&gt;

&lt;h3&gt;解决步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://xquartz.macosforge.org/landing/&quot;&gt;XQuartz&lt;/a&gt;下载&lt;code&gt;XQuartz-2.7.7.dmg&lt;/code&gt;，并安装更新。&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行命令：&lt;code&gt;
sudo ln -s /opt/X11/ /usr/X11
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载并安装&lt;a href=&quot;http://support.apple.com/kb/DL1572&quot;&gt;Java 6&lt;/a&gt;更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;完成✌️&lt;/h3&gt;

&lt;p&gt;OK，现在Matlab就能重新工作了。&lt;/p&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;

&lt;p&gt;[1]&lt;a href=&quot;http://brainsuite.org/quickstart/installation/mac/yosemite/&quot;&gt; running svreg and bdp on yosemite (os x 10.10)&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Mac安装unrar和rar解压缩工具</title>
        <link>http://painterlin.com/2014/10/07/Mac-Rar-Unrar.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/10/07/Mac-Rar-Unrar.html</guid>
        <pubDate>Tue, 07 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;问题描述&lt;/h3&gt;

&lt;p&gt;Mac不能解压rar文件，但实际中会需要这项功能。比如从邮件中的附件时常以rar文件格式传输。&lt;/p&gt;

&lt;h3&gt;步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&quot;http://www.rarlab.com/download.htm&quot;&gt;rarlab&lt;/a&gt;下载&lt;code&gt;RAR 5.20 beta 1 for Mac OS X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开Mac终端，执行解压缩命令：tar xvfz rarosx-5.2.b1.tar进行解压&lt;/li&gt;
&lt;li&gt;进入刚刚解压的rar目录中，cd downloads/rar&lt;/li&gt;
&lt;li&gt;在rar目录下使用如下命令进行安装&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo install -c -o$USER unrar /bin
sudo install -c -o$USER rar /bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;解压与压缩&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;unrar x filename.rar             #解压
rar a archivename.rar filename   #压缩
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后记&lt;/h3&gt;

&lt;p&gt;为什么要折腾这个，因为今天收到一份rar格式的文件。
转眼一年了，好快啊。这是要每年送我一个生日蛋糕的节奏吗？如果是的话，这篇博客需要每年更新一次。&lt;/p&gt;

&lt;h4&gt;2013年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2014年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/2.jpg&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2015年&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/birthday/3.jpg&quot; alt=&quot;3&quot;&gt;&lt;/p&gt;

&lt;h3&gt;谢意&lt;/h3&gt;

&lt;p&gt;蒲俊楠童鞋，阿里嘎多~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Learn Algorithms Ten - Dynamic programming</title>
        <link>http://painterlin.com/2014/10/02/Learn-Algorithms-Ten.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/10/02/Learn-Algorithms-Ten.html</guid>
        <pubDate>Thu, 02 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;10.1 Dynamic programming&lt;/p&gt;

&lt;p&gt;What is the Dynamic programming?&lt;/p&gt;

&lt;p&gt;Dynamic programming, like the divide-and-conquer method, solves problems by combining the solutions to subproblems.&lt;/p&gt;

&lt;p&gt;A Dynamic programming algorithm solves every subsubproblem just once and then saves its anser in a table, thereby avoiding the work of recomputing the answer every tiem the subsubproblem is encountered.&lt;/p&gt;

&lt;p&gt;There are four steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Characterize the structure of an optimal solution&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recursively define the value of an optimal solution&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compute the value of an optimal solution in a bottom-up fashion&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Construct an optimal solution from computed information&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;10.1.1 Assembly-Line scheduling&lt;/p&gt;

&lt;p&gt;There four steps to assolve this problem:&lt;/p&gt;

&lt;p&gt;Step 1: The structure of the fastest way through the factory.&lt;/p&gt;

&lt;p&gt;Step 2: A recursive solution.&lt;/p&gt;

&lt;p&gt;Step 3: Computing the fastest times.&lt;/p&gt;

&lt;p&gt;Step 4: Constructing the fastest way through the factory.&lt;/p&gt;

&lt;p&gt;Assembly&lt;em&gt;Line&lt;/em&gt;Scheduling Code:
```
    #include &lt;iostream&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;using namespace std;

void dynamic_assline_schedule()
{
  int i,j;
    int temp;
    int schedule_rec_one[10] = {0};
    int schedule_rec_two[10] = {0};
    int tot_time[2][10];
    int ass_station_time_assumption[2][10];
    int ass_sta_tranfer_time_assumption[2][10];

    temp = 0;
    memset(tot_time,0,sizeof(tot_time));
    memset(ass_station_time_assumption,0,sizeof(ass_station_time_assumption));
    memset(ass_sta_tranfer_time_assumption,0,sizeof(ass_sta_tranfer_time_assumption));

    cout &amp;lt;&amp;lt; &amp;quot;ass_station_time_assumption:&amp;quot; &amp;lt;&amp;lt; endl;
/*  for(i = 1; i &amp;lt;= 2; i++)
    {
        if (i == 1)
        {
            cout &amp;lt;&amp;lt; &amp;quot;Station One:&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;Station Two:&amp;quot; &amp;lt;&amp;lt; endl;
        }

        for(j = 1; j &amp;lt;= 6; j++)
        {
            cin &amp;gt;&amp;gt; ass_station_time_assumption[i][j];
        }

    }

    cout &amp;lt;&amp;lt; &amp;quot;ass_sta_tranfer_time_assumption:&amp;quot; &amp;lt;&amp;lt; endl;

    for(i = 1; i &amp;lt;= 2; i++)
    {
        if (i == 1)
        {
            cout &amp;lt;&amp;lt; &amp;quot;Transfer One:&amp;quot; &amp;lt;&amp;lt; endl;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;Transfer Two:&amp;quot; &amp;lt;&amp;lt; endl;
        }

        for(j = 1; j &amp;lt;= 7; j++)
        {
            cin &amp;gt;&amp;gt; ass_sta_tranfer_time_assumption[i][j];
        }
    }*/
    ass_station_time_assumption[1][1] = 7;
    ass_station_time_assumption[1][2] = 9;
    ass_station_time_assumption[1][3] = 3;
    ass_station_time_assumption[1][4] = 4;
    ass_station_time_assumption[1][5] = 8;
    ass_station_time_assumption[1][6] = 4;

    ass_station_time_assumption[2][1] = 8;
    ass_station_time_assumption[2][2] = 5;
    ass_station_time_assumption[2][3] = 6;
    ass_station_time_assumption[2][4] = 4;
    ass_station_time_assumption[2][5] = 5;
    ass_station_time_assumption[2][6] = 7;

    ass_sta_tranfer_time_assumption[1][1] = 2;
    ass_sta_tranfer_time_assumption[1][2] = 2;
    ass_sta_tranfer_time_assumption[1][3] = 3;
    ass_sta_tranfer_time_assumption[1][4] = 1;
    ass_sta_tranfer_time_assumption[1][5] = 3;
    ass_sta_tranfer_time_assumption[1][6] = 4;
    ass_sta_tranfer_time_assumption[1][7] = 3;

    ass_sta_tranfer_time_assumption[2][1] = 4;
    ass_sta_tranfer_time_assumption[2][2] = 2;
    ass_sta_tranfer_time_assumption[2][3] = 1;
    ass_sta_tranfer_time_assumption[2][4] = 2;
    ass_sta_tranfer_time_assumption[2][5] = 2;
    ass_sta_tranfer_time_assumption[2][6] = 1;
    ass_sta_tranfer_time_assumption[2][7] = 2;

    schedule_rec_one[1] = 1;
    schedule_rec_two[1] = 2;

    tot_time[1][1] = ass_station_time_assumption[1][1] + ass_sta_tranfer_time_assumption[1][1]; //9
    tot_time[2][1] = ass_station_time_assumption[2][1] + ass_sta_tranfer_time_assumption[2][1]; //12

    for(i = 2; i &amp;lt;= 6; i++)
    {
        if ((tot_time[1][i - 1] + ass_station_time_assumption[1][i]) &amp;lt; (tot_time[2][i - 1] + ass_sta_tranfer_time_assumption[2][i] + ass_station_time_assumption[1][i]))
        {
            schedule_rec_one[i] = 1;
            temp = (tot_time[1][i - 1] + ass_station_time_assumption[1][i]);
            tot_time[1][i] = temp;
        }
        else
        {
            schedule_rec_one[i] = 2;
            temp = (tot_time[2][i - 1] + ass_sta_tranfer_time_assumption[2][i] + ass_station_time_assumption[1][i]);
            tot_time[1][i] = temp;
        }

        if ((tot_time[2][i - 1] + ass_station_time_assumption[2][i]) &amp;lt; (tot_time[1][i - 1] + ass_sta_tranfer_time_assumption[1][i] + ass_station_time_assumption[2][i]))
        {
            schedule_rec_two[i] = 2;
            temp = (tot_time[2][i - 1] + ass_station_time_assumption[2][i]);
            tot_time[2][i] = temp;
        }
        else
        {
            schedule_rec_two[i] = 1;
            temp = (tot_time[1][i - 1] + ass_sta_tranfer_time_assumption[1][i] + ass_station_time_assumption[2][i]);
            tot_time[2][i] = temp;
        }
    }

    if (tot_time[1][6] &amp;lt; tot_time[2][6])
    {
        tot_time[1][7] = tot_time[1][6] + ass_sta_tranfer_time_assumption[1][7];
        schedule_rec_one[7] = 1;
        cout &amp;lt;&amp;lt; &amp;quot;Schedule one use time:&amp;quot;&amp;lt;&amp;lt; tot_time[1][7] &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;Trace:&amp;quot; &amp;lt;&amp;lt; endl;
        for(i = 1; i &amp;lt;= 7; i++)
        {
            cout &amp;lt;&amp;lt; schedule_rec_one[i] &amp;lt;&amp;lt; &amp;quot;_&amp;quot;;
        }
    }
    else
    {
        tot_time[2][7] = tot_time[2][6] + ass_sta_tranfer_time_assumption[2][7];
        schedule_rec_two[7] = 2;
        cout &amp;lt;&amp;lt; &amp;quot;Schedule two use time:&amp;quot;&amp;lt;&amp;lt; tot_time[1][7] &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; &amp;quot;Trace:&amp;quot; &amp;lt;&amp;lt; endl;
        for(i = 1; i &amp;lt;= 7; i++)
        {
            cout &amp;lt;&amp;lt; schedule_rec_two[i] &amp;lt;&amp;lt; &amp;quot;_&amp;quot;;
        }
    }
}

int main()
{
    cout&amp;lt;&amp;lt;&amp;quot;Dynamic Schedule:&amp;quot; &amp;lt;&amp;lt; endl;
    dynamic_assline_schedule();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;10.1.2 Matrix-chain multiplication
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>阿里巴巴大数据竞赛回顾与总结</title>
        <link>http://painterlin.com/2014/10/01/Alibaba-Big-Data.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/10/01/Alibaba-Big-Data.html</guid>
        <pubDate>Wed, 01 Oct 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;8个月前，苏宇师兄问我对&lt;a href=&quot;http://102.alibaba.com/competition/addDiscovery/index.htm&quot;&gt;阿里巴巴大数据竞赛&lt;/a&gt;感兴趣吗。正好我选修了&lt;a href=&quot;http://staff.ustc.edu.cn/%7Echeneh/&quot;&gt;陈恩红&lt;/a&gt;老师的《机器学习与数据挖掘》，很好奇这门课在实际中的应用；身为淘宝用户，也好奇我是如何被推荐的。于是和师兄一起参加比赛，加上计算机学院的刘惠民同学，我们组成了名叫&lt;code&gt;Rosemary&lt;/code&gt;三人团队。这次大赛总共有7276支队伍参赛，我们止步于第二赛季。第一赛季排名56；第二赛季排名68。&lt;/p&gt;

&lt;h3&gt;开放数据&lt;/h3&gt;

&lt;table  class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
   &lt;tr&gt;
     &lt;th&gt;字段&lt;/th&gt;
      &lt;th&gt;字段说明&lt;/th&gt;
      &lt;th&gt;提取说明&lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;user_id&lt;/td&gt;
      &lt;td&gt;用户标记&lt;/td&gt;
      &lt;td&gt;抽样、字段加密&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;Time&lt;/td&gt;
      &lt;td&gt;行为时间&lt;/td&gt;
      &lt;td&gt;精度到天级别、隐藏年份&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;action_type&lt;/td&gt;
      &lt;td&gt;用户对品牌的行为类型&lt;/td&gt;
      &lt;td&gt;包括点击（0）、购买（1）、加入购物车（2）、收藏（3）四种行为 &lt;/td&gt;
  &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;brand_id&lt;/td&gt;
      &lt;td&gt;品牌数字ID&lt;/td&gt;
      &lt;td&gt;抽样、字段加密&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;比赛任务&lt;/h3&gt;

&lt;p&gt;根据用户4个月在天猫的行为日志，建立用户的品牌偏好，并预测他们在将来一个月内对品牌下商品的购买行为。&lt;/p&gt;

&lt;h3&gt;评估指标&lt;/h3&gt;

&lt;p&gt;大赛最终的比赛成绩排名以F1得分为准。&lt;/p&gt;

&lt;p&gt;准确率：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Precision=\frac{\sum_i^N&amp;space;hitBrands_i}{\sum_i^N&amp;space;pBrands_i}&quot; title=&quot;Precision=\frac{\sum_i^N hitBrands_i}{\sum_i^N pBrands_i}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;召回率：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?Recall=\frac{\sum_i^M&amp;space;hitBrands_i}{\sum_i^M&amp;space;bBrands_i}&quot; title=&quot;Recall=\frac{\sum_i^M hitBrands_i}{\sum_i^M bBrands_i}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;F1-Score：&lt;img src=&quot;http://latex.codecogs.com/gif.latex?F_1=\frac{2\times&amp;space;P\times&amp;space;R}{P&amp;plus;R}&quot; title=&quot;F_1=\frac{2\times P\times R}{P+R}&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;N 为参赛队预测的用户数；M 为实际产生成交的用户数量&lt;br&gt;&lt;/li&gt;
&lt;li&gt;pBrandsi为对用户i 预测他(她)会购买的品牌列表个数；bBrandsi为用户i 真实购买的品牌个数 &lt;/li&gt;
&lt;li&gt;hitBrandsi对用户i预测的品牌列表与用户i真实购买的品牌交集的个数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;解读&lt;code&gt;准确率&lt;/code&gt;、&lt;code&gt;召回率&lt;/code&gt;和&lt;code&gt;F1-Score&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;准确率就是正确预测数目比上预测总数目。召回率就是正确预测数目比上真实总数目。F1-Score是准确率和召回率的调和平均。理论上，准确率与召回率并没有必然的联系；但在实际中，这二者往往此消彼长、相互制约。有研究表明，在不牺牲准确率的情况下，获得一个高召回率是很难的。在赛题环境下举个栗子：&lt;/p&gt;

&lt;table  class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
   &lt;tr&gt;
     &lt;th&gt;我们预测出&lt;/th&gt;
      &lt;th&gt;会有3个人买东西，A买品牌a，B买品牌b，C买P品牌c&lt;/th&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;真实情况是&lt;/td&gt;
      &lt;td&gt;有4个人买了东西，这4个人分别是A，B，C，D，其中A买a和b，B买b，C买b和c，D买a。&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;按照我们的预测，准确率达到了100%，而召回率仅为50%。由此可见，想取得一个较好的F1-Score成绩，需要保证预测的数据尽量hit之外，还要保证预测的数据能够覆盖尽量多的真实数据。具体到比赛中，就需要很好地确定每个被预测的用户可能会买多少个品牌。&lt;/p&gt;

&lt;p&gt;通过对这三个评判标准的分析，我们初步确定了第一赛季所用的策略。&lt;/p&gt;

&lt;h3&gt;第一赛季&lt;/h3&gt;

&lt;p&gt;大致的方案是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加权对用户4种行为次数求和，得到简单的用户ID（行）与品牌ID（列）的&lt;code&gt;兴趣度&lt;/code&gt;（值）矩阵。&lt;/li&gt;
&lt;li&gt;统计前4个月平均每个月有多少用户购买超过2个品牌的东西，记为B。&lt;/li&gt;
&lt;li&gt;根据用户前4个月的购买行为，按照&lt;code&gt;购买力&lt;/code&gt;划分用户购买等级。直白解释就是你以前在天猫上平均每个月买了多少次，我就假设你下个月还会买这么多次。&lt;/li&gt;
&lt;li&gt;第一次切分兴趣度矩阵，保留前B行矩阵。&lt;/li&gt;
&lt;li&gt;对每个用户对不同品牌的兴趣度由高到低排序，再根据每个用户的购买力确定对该用户保留前n列的兴趣数据，并预测他会买这n个数据对应的品牌。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，在最初的模型建立起来之后，我们还陆续加了一些规则，比如在&lt;code&gt;时间节截止点&lt;/code&gt;(最后N天，N可以根据自己的理解取值)的单独分析。另外，调参数真就是一项体力活。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/s1.jpg&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第二赛季&lt;/h3&gt;

&lt;p&gt;（好困，需要去睡觉Zzz···）细节未完待续&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/posts/score0.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;
</description>
      </item>
    
      <item>
        <title>Linux 4：磁盘与文件系统管理</title>
        <link>http://painterlin.com/2014/09/30/Linux4.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/09/30/Linux4.html</guid>
        <pubDate>Tue, 30 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3&gt;认识EXT2文件系统&lt;/h3&gt;

&lt;p&gt;每种操作系统能够使用的文件系统并不相同。 举例来说，windows 98以前的微软操作系统主要利用的文件系统是&lt;code&gt;FAT(或FAT16)&lt;/code&gt;，windows 2000以后的版本有所谓的&lt;code&gt;NTFS&lt;/code&gt;文件系统，至于Linux的正统文件系统则为&lt;code&gt;Ext2&lt;/code&gt;(Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows操作系统是不会认识Linux的Ext2的。&lt;/p&gt;

&lt;p&gt;那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如Linux操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到&lt;code&gt;inode&lt;/code&gt;中，至于实际数据则放置到&lt;code&gt;data block&lt;/code&gt;区块中。 另外，还有一个超级区块(&lt;code&gt;superblock&lt;/code&gt;)会记录整个文件系统的整体信息，包括inode与block的总量、使用量、剩余量等。&lt;/p&gt;

&lt;h3&gt;文件系统的简单操作&lt;/h3&gt;

&lt;h3&gt;磁盘的分割、格式化、检验与挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;磁盘分区： fdisk, partprobe&lt;/li&gt;
&lt;li&gt;磁盘格式化： mkfs, mke2fs&lt;/li&gt;
&lt;li&gt;磁盘检验： fsck, badblocks&lt;/li&gt;
&lt;li&gt;磁盘挂载与卸除： mount, umount&lt;/li&gt;
&lt;li&gt;磁盘参数修订： mknod, e2label, tune2fs, hdparm&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;配置启动挂载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;启动挂载 /etc/fstab 及 /etc/mtab&lt;/li&gt;
&lt;li&gt;特殊装置 loop 挂载(映象档不刻录就挂载使用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;内存置换空间(swap)之建置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用实体分割槽建置swap&lt;/li&gt;
&lt;li&gt;使用文件建置swap&lt;/li&gt;
&lt;li&gt;swap使用上的限制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;文件系统的特殊观察与操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;boot sector 与 superblock 的关系&lt;/li&gt;
&lt;li&gt;磁盘空间之浪费问题&lt;/li&gt;
&lt;li&gt;利用 GNU 的 parted 进行分割行为&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;重点回顾&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本上 Linux 的正统文件系统为 Ext2 ，该文件系统内的信息主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；&lt;/li&gt;
&lt;li&gt;inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；&lt;/li&gt;
&lt;li&gt;block：实际记录文件的内容，若文件太大时，会占用多个 block 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2 文件系统的数据存取为索引式文件系统(indexed allocation)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;inode 记录文件的属性/权限等数据，其他重要项目为： 每个 inode 大小均固定为 128 bytes； 每个文件都仅会占用一个 inode 而已； 因此文件系统能够创建的文件数量与 inode 的数量有关；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录底下文件名与其 inode 号码的对照表；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志式文件系统 (journal) 会多出一块记录区，随时记载文件系统的主要活动，可加快系统复原时间；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Linux 文件系统为添加效能，会让主存储器作为大量的磁盘高速缓存；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实体链接只是多了一个文件名对该 inode 号码的链接而已；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;符号链接就类似Windows的快捷方式功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;磁盘的使用必需要经过：分割、格式化与挂载，分别惯用的命令为：fdisk, mkfs, mount三个命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动自动挂载可参考/etc/fstab之配置，配置完毕务必使用 mount -a 测试语法正确否；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem.php#harddisk&quot;&gt;鸟哥的Linux私房菜 第八章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>Learn Statistics One</title>
        <link>http://painterlin.com/2014/09/27/Learn-Statistics-One.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/09/27/Learn-Statistics-One.html</guid>
        <pubDate>Sat, 27 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;hr&gt;

&lt;p&gt;layout: post
keywords: Statistics
description: Learn Statistics
title: &amp;quot;Learn Statistics One&amp;quot;
categories: Statistics C++&amp;amp;Python
tags: Statistics
group: archive&lt;/p&gt;

&lt;h2&gt;icon: key&lt;/h2&gt;

&lt;h1&gt;Session 1&lt;/h1&gt;

&lt;p&gt;1.1 Basic concepts
What is Statistics?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Statistics&lt;/strong&gt; is the study of the collection,organization analysis, interpretation, presentation and orgasim of data.[1] It deals with all aspects of data including the planning of data collection in terms of the design of surveys and experiments.[1] When analyzing data, it is possible to use one of two statistics methodologies: descriptive statistics or inferential statistics.&lt;/p&gt;

&lt;p&gt;Descriptive statistics can be used to summarize the population data. Numerical descriptors include mean and standard deviation for continuous data types (like income), while frequency and percentage are more useful in terms of describing categorical data (like race).&lt;/p&gt;

&lt;p&gt;When you click the &lt;strong&gt;Knit HTML&lt;/strong&gt; button a web page will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;kp&quot;&gt;summary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;##      speed           dist    
##  Min.   : 4.0   Min.   :  2  
##  1st Qu.:12.0   1st Qu.: 26  
##  Median :15.0   Median : 36  
##  Mean   :15.4   Mean   : 43  
##  3rd Qu.:19.0   3rd Qu.: 56  
##  Max.   :25.0   Max.   :120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can also embed plots, for example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;plot&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;cars&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Learn Algorithms One</title>
        <link>http://painterlin.com/2014/09/27/Learn-Algorithms-One.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/09/27/Learn-Algorithms-One.html</guid>
        <pubDate>Sat, 27 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1.1 Algorithms&lt;/p&gt;

&lt;p&gt;What is the algorithms?&lt;/p&gt;

&lt;p&gt;An algorithms is thus a sequence of computational steps that transform the input into the output.&lt;/p&gt;

&lt;p&gt;Data Structure&lt;/p&gt;

&lt;p&gt;A data structure is a way to store and organize data in order to facilitate access and modifications. No single data structure works well for all purposes, and so it is important to know the strenghs and limitations of several of them.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Six</title>
        <link>http://painterlin.com/2014/09/20/Learn-Python-Exercise-Six.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/09/20/Learn-Python-Exercise-Six.html</guid>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Data Structure:&lt;/p&gt;

&lt;p&gt;This session show how to use the list, set, tuple, dict, looping etc.&lt;/p&gt;

&lt;p&gt;learn_datastructure.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/21/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
Data Type
List example:
[&amp;quot;list1&amp;quot;,&amp;quot;list2&amp;quot;,&amp;quot;list3&amp;quot;]

list.append(x)
Add an item to the end of the list; equivalent to a[len(a):] = [x].

list.extend(L)
Extend the list by appending all the items in the given list; equivalent to a[len(a):] = L.

list.insert(i, x)
Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x).

list.remove(x)
Remove the first item from the list whose value is x. It is an error if there is no such item.

list.pop([i])
Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.)

list.index(x)
Return the index in the list of the first item whose value is x. It is an error if there is no such item.

list.count(x)
Return the number of times x appears in the list.

list.sort(cmp=None, key=None, reverse=False)
Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for their explanation).

list.reverse()
Reverse the elements of the list, in place.
&amp;quot;&amp;quot;&amp;quot;
def listType(params):
    print(&amp;quot;print list items below:&amp;quot;)

    for i in params:
        print i, len(i)

def my_reverse(x,y):
    if x &amp;gt; y:
        return -1
    if x &amp;lt; y:
        return 1
    return 0

def filter_func(x):
    return x%2 != 0 and x%3 !=0

def reduce_add(x,y):
    return  x + y

def map_add(x):
    return x + x

def char2int(str):
    return {&amp;#39;0&amp;#39;: 0, &amp;#39;1&amp;#39;: 1, &amp;#39;2&amp;#39;: 2, &amp;#39;3&amp;#39;: 3, &amp;#39;4&amp;#39;: 4, &amp;#39;5&amp;#39;: 5, &amp;#39;6&amp;#39;: 6, &amp;#39;7&amp;#39;: 7, &amp;#39;8&amp;#39;: 8, &amp;#39;9&amp;#39;: 9}[str]

def str2int(str):
    return reduce(lambda x, y: x * 10 + y, map(char2int, str))

&amp;quot;&amp;quot;&amp;quot;
Tuple:
tup = (1,2,3,4,5)
Very like to list. But tuple is immutable!
&amp;quot;&amp;quot;&amp;quot;
def show_tuple_structure():

    tup_one = 1,2,3,4,5
    tup_two = 1235,&amp;#39;tuple_item&amp;#39;
    tup_three = tup_one, tup_two
    tup_list = ([1,2,3],[5,6,7])
    tup_four = &amp;#39;hello_tuple&amp;#39;,

    print &amp;quot;Print tuple:&amp;quot;
    print tup_one
    print tup_two
    print tup_three
    print tup_list
    print tup_four

&amp;quot;&amp;quot;&amp;quot;
Set:
A set is an unordered collection with no duplicate elements. 
Basic uses include membership testing and eliminating duplicate entries.
Set objects also support mathematical operations like union, intersection, difference, and symmetric difference.
set(list)
&amp;quot;&amp;quot;&amp;quot;
def show_set_structure():
    print &amp;quot;set:&amp;quot;
    basket = [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;apple&amp;#39;, &amp;#39;pear&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;banana&amp;#39;]
    print basket
    set(basket)
    print basket

    set_a = set(&amp;#39;abracadabra&amp;#39;)
    set_b = set(&amp;#39;alacazam&amp;#39;)
    # use operations, monitor the set operations
    print &amp;quot;set_a, set_b:&amp;quot;,set_a, set_b
    print &amp;quot;set_a - set_b:&amp;quot;, set_a - set_b
    print &amp;quot;set_a | b:&amp;quot;, set_a|set_b
    print &amp;quot;set_a &amp;amp; set_b:&amp;quot;, set_a&amp;amp;set_b
    print &amp;quot;set_a ^ set_b:&amp;quot;, set_a ^ set_b


&amp;quot;&amp;quot;&amp;quot;
Data type
Dictionary
    It define key-value relationship. {key, value}
    Example:
    {&amp;quot;server&amp;quot;:&amp;quot;huangmoyue&amp;quot;, &amp;quot;pwd&amp;quot;:&amp;quot;12345&amp;quot;}
&amp;quot;&amp;quot;&amp;quot;

def dictionaryType():
    print(&amp;quot;dic type:&amp;quot;)

    dic_a = {&amp;quot;Server&amp;quot;:&amp;quot;huangmoyue&amp;quot;,&amp;quot;Pwd&amp;quot;:&amp;quot;861117&amp;quot;}
    dic_b = {&amp;#39;jack&amp;#39;: 4098, &amp;#39;sape&amp;#39;: 4139}

    print dic_a.keys()
    print dic_b[&amp;quot;jack&amp;quot;]

    for key, value in dic_a.items():
        print(&amp;quot;;&amp;quot;.join((key, value)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;testing_datastructure.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/21/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

import unittest
from unittest import TestCase

from learnpy.learning_datastructure import listType
from learnpy.learning_datastructure import my_reverse
from learnpy.learning_datastructure import filter_func
from learnpy.learning_datastructure import reduce_add
from learnpy.learning_datastructure import map_add
from learnpy.learning_datastructure import str2int
from learnpy.learning_datastructure import show_tuple_structure
from learnpy.learning_datastructure import show_set_structure
from learnpy.learning_datastructure import dictionaryType

class Test_DataType(TestCase):
    def test_listtype(self):
        test_list = [&amp;quot;list1&amp;quot;,&amp;quot;list2&amp;quot;,&amp;quot;list3&amp;quot;]
        listType(test_list)

    def test_list_inernal_function(self):
        test_list = [66.25, 333, 333, 1, 1234.5]

        #append 100 behind the test_list
        test_list.append(100)
        print &amp;quot;append 100 behind:&amp;quot;, test_list

        #extend 
        ex_list = [&amp;quot;extend_item1&amp;quot;, &amp;quot;extend_item2&amp;quot;]
        test_list.extend(ex_list)
        print &amp;quot;extend two items:&amp;quot;, test_list

        #insert
        test_list.insert(3,&amp;quot;insert_item&amp;quot;)
        print &amp;quot;insert one item:&amp;quot;, test_list

        #remove
        test_list.remove(333)
        print &amp;quot;remove 333 from test_list:&amp;quot;,test_list

        #pop
        test_list.pop()
        print &amp;quot;Use pop funtion:&amp;quot;,test_list
        test_list.pop(0)
        print &amp;quot;Use pop to remove 66.25:&amp;quot;,test_list

        #index
        print &amp;quot;Show index(0) position:&amp;quot;, test_list.index(1)

        #count
        print &amp;quot;Show the extend_item1 position:&amp;quot;, test_list.count(&amp;quot;extend_item1&amp;quot;)

        #sort
        print &amp;quot;Show before:&amp;quot;,test_list
        test_list.sort()
        print &amp;quot;Show sort after:&amp;quot;,test_list

        #sorted use user define function
        print &amp;quot;Show before:&amp;quot;, test_list
        sorted(test_list,my_reverse)
        print &amp;quot;Show my own sort function:&amp;quot;,sorted(test_list,my_reverse)

    #filter(function, sequence) returns a sequence consisting of those items from the sequence for which function(item) is true. If sequence is a string or tuple, the result will be of the same type; otherwise, it is always a list. 
    #map(function, sequence) calls function(item) for each of the sequence’s items and returns a list of the return values. 
    #reduce(function, sequence) returns a single value constructed by calling the binary function function on the first two items of the sequence, then on the result and the next item, and so on.
    def test_functional_tools(self):
        print &amp;quot;Show how to use the filter:&amp;quot;, filter(filter_func,range(2,25))
        print &amp;quot;Show how to use the reduece:&amp;quot;,reduce(reduce_add, [1, 3, 5, 7, 9])
        print &amp;quot;Show how to use the map:&amp;quot;, map(map_add, [1, 2, 3, 4, 5, 6, 7, 8, 9])
        print &amp;quot;Show how the map and reduece work together:&amp;quot;, str2int(&amp;quot;123456&amp;quot;)


    #List comprehensions
    def test_list_comprehensions(self):
        #The tranditional way to create the list

        print &amp;quot;List Comprehensions:&amp;quot;
        test_tra_list = []
        for x in range(10):
            test_tra_list.append(x)
        print test_tra_list

        #Obtain the same value in list
        test_comprehensions_list = [x for x in range(10)]
        print test_comprehensions_list

        #Another case
        test_comb_list = []
        for x in [1,2,3]:
            for y in [3,1,4]:
                if x != y:
                    test_comb_list.append((x,y))

        print test_comb_list        

        test_pre_comb_list = [(x,y) for x in [1,2,3] for y in [2,1,4] if x != y]
        print test_pre_comb_list

    #Nested List Comprehensions
    def test_list_nested_compreh(self):
        print &amp;quot;nested List comprehension:&amp;quot;
        matrix = [
                  [1,2,3,4],
                  [5,6,7,8],
                  [9,10,11,12],
                  [13,14,15,16]
                  ]
        #Some matrix tranform methods:
        tran_one = [[row[i] for row in matrix] for i in range(4)]
        print &amp;quot;tran_one:&amp;quot;, tran_one

        tran_two = zip(*matrix)
        print &amp;quot;tran_two:&amp;quot;, tran_two

        tran_three = []
        for i in range(4):
            tran_three.append([row[i] for row in matrix])
        print &amp;quot;tran_three&amp;quot;, tran_three

        tran_four = []
        for i in range(4):
            tran_four_row = []
            for row in matrix:
                tran_four_row.append(row[i])
            tran_four.append(tran_four_row)
        print &amp;quot;tran_four:&amp;quot;, tran_four

    #Use del to remove the list item
    def test_del(self):
        print &amp;quot;del item:&amp;quot;
        test_list = [&amp;quot;list1&amp;quot;,&amp;quot;list2&amp;quot;,&amp;quot;list3&amp;quot;]
        print test_list
        del test_list[0]
        print test_list

        del test_list       

    # tuple
    def test_tuple(self):
        show_tuple_structure()

    #set
    def test_set(self):
        show_set_structure()
        #set comprehensions
        test_set_compre = {x for x in &amp;#39;abracadabra&amp;#39; if x not in &amp;#39;abc&amp;#39;}
        print &amp;quot;set comprehensions:&amp;quot;,test_set_compre

    #Dict
    def test_dict(self):
        dictionaryType()
        #The dict() constructor builds dictionaries directly from sequences of key-value pairs
        print &amp;quot;Use the dict() constructor to build the dict:&amp;quot;
        print dict(sape=4139, guido=4127, jack=4098)
        print dict([(&amp;#39;sape&amp;#39;, 4139), (&amp;#39;guido&amp;#39;, 4127), (&amp;#39;jack&amp;#39;, 4098)])
        print {x: x**2 for x in (2, 4, 6)}

    #Looping Techniques
    def test_looping(self):
        print &amp;quot;test Loop:&amp;quot;
        print &amp;quot;Use Enumerate:&amp;quot;
        for i, v in enumerate([&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;]):
            print i, v

        print &amp;quot;show two or more sequence one time:&amp;quot;
        questions = [&amp;#39;name&amp;#39;, &amp;#39;quest&amp;#39;, &amp;#39;favorite color&amp;#39;]
        answers = [&amp;#39;lancelot&amp;#39;, &amp;#39;the holy grail&amp;#39;, &amp;#39;blue&amp;#39;]
        for q, a in zip(questions, answers):
            print &amp;quot;what&amp;#39;s your {0}? It is {1}.&amp;quot;.format(q,a)

        print &amp;quot;Show reverse sequence: &amp;quot;
        for i in reversed(range(1,20,2)):
            print i

        print &amp;quot;Show sorted sequence:&amp;quot;
        basket = [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;apple&amp;#39;, &amp;#39;pear&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;banana&amp;#39;]
        for s in sorted(set(basket)):
            print s

        print &amp;quot;Show the dict item&amp;#39;s key-value:&amp;quot;
        dic_a = {&amp;quot;Server&amp;quot;:&amp;quot;huangmoyue&amp;quot;,&amp;quot;Pwd&amp;quot;:&amp;quot;861117&amp;quot;}
        for k, v in dic_a.iteritems():
            print k, v
            print &amp;quot;;&amp;quot;.join((k,v))

    #slicing operations
    def test_slicing(self):
        print &amp;quot;Use slicing:&amp;quot;
        words = [&amp;#39;cat&amp;#39;, &amp;#39;window&amp;#39;, &amp;#39;defenestrate&amp;#39;]
        print words[:]
        print words[2:3]
        print words[-2:-1]


if __name__ == &amp;#39;__main__&amp;#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Seven</title>
        <link>http://painterlin.com/2014/09/20/Learn-Python-Exercise-Seven.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/09/20/Learn-Python-Exercise-Seven.html</guid>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Classes&lt;/p&gt;

&lt;p&gt;From python doc&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learning_class.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/20/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
class structure 
class class_name:
    &amp;lt;statement - 1&amp;gt;
    &amp;lt;statement - 1&amp;gt;
&amp;quot;&amp;quot;&amp;quot;

class My_Class:
    #Called when the instance is created. 
    def __init__(self):
        self.data = []

class Complex:
    def __init__(self,realpart,implpart):
        self.r = realpart
        self.i = implpart

class Dog:
    def __init__(self, name):
        self.name = name
        self.tricks = []

    def add_trick(self, trick):
        self.tricks.append(trick)

#Inheritance
&amp;quot;&amp;quot;&amp;quot;
inheritance class structure
class DerivedClass(BaseClass):
&amp;quot;&amp;quot;&amp;quot;

class Animal(object):
    def run(self):
        print &amp;quot;Animal is running...&amp;quot;
    def __len__(self):
        return 1000


class Cat(Animal):
    def run(self):
        print &amp;quot;Cat is running....&amp;quot;

    def eat(self):
        print &amp;quot;Cat eat rat....&amp;quot;

class Horse(Animal):
    def run(self):
        print &amp;quot;Horse is running....&amp;quot;
    def eat(self):
        print &amp;quot;Horse is eat glass....&amp;quot;

#:polymorphic testing. Put the father type in testing function as var.
def run_twice(animal):
    animal.run()
    animal.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;testing_class.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/19/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;


import unittest
from unittest import TestCase

from learnpy.learning_class import My_Class
from learnpy.learning_class import Complex
from learnpy.learning_class import Dog
from learnpy.learning_class import Animal
from learnpy.learning_class import Cat
from learnpy.learning_class import Horse
from learnpy.learning_class import run_twice

class Test_Class(TestCase):

    def test_init(self):
        x = My_Class()
        x = [1,2,3,4,5,6]
        print x

        y = Complex(5,6)
        print y.r, y.i


    def test_dog(self):
        cla = Dog(&amp;quot;cla&amp;quot;)
        cla.add_trick(&amp;quot;trick_1&amp;quot;)
        cla.add_trick(&amp;quot;trick_2&amp;quot;)

        print cla.name
        print cla.tricks


    def test_inheritance(self):
        ins_cat = Cat();
        ins_horse = Horse();

        ins_cat.run()
        ins_horse.run()

        ins_cat.eat()
        ins_horse.eat()


    def test_instance(self):
        test_a = list()
        test_b = Cat()
        test_c = Horse()
        test_d = Animal()

        if isinstance(test_a, list):
            print &amp;quot;test_a is the list type!&amp;quot;
        else:
            print &amp;quot;test_a is not the list type!&amp;quot;

        if isinstance(test_b, Cat):
            print &amp;quot;test_is the Cat type!&amp;quot;
        else:
            print &amp;quot;test_b is not the Cat type!&amp;quot;

        if isinstance(test_c, Horse):
            print &amp;quot;test_c is the Horse type!&amp;quot;
        else:
            print &amp;quot;test_c is not the Horse type!&amp;quot;

        if isinstance(test_d, Animal):
            print &amp;quot;test_d the Animal type!&amp;quot;
        else:
            print &amp;quot;test_d is not the Animal type!&amp;quot;

        if isinstance(test_d, Horse):
            print &amp;quot;test_d is the Horse&amp;quot;
        else:
            print &amp;quot;test_d is not the Horse type!&amp;quot;

        #Testing the polymorphic
        run_twice(test_b)
        run_twice(test_c)
        run_twice(test_d)

        #Like __**__() function just have sepcial use in the python
        #We can mock __len__() function
        #Let the sys know our class have length
        print  test_d.__len__()
        print  test_c.__len__()
        print  test_b.__len__()

        #dir()
        #This function will show the all methods and attributes 
        print dir(test_d)   

if __name__ == &amp;#39;__main__&amp;#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
      <item>
        <title>Learn Python Exercise Five</title>
        <link>http://painterlin.com/2014/09/20/Learn-Python-Exercise-Five.html</link>
        <guid isPermaLink="true">http://painterlin.com/2014/09/20/Learn-Python-Exercise-Five.html</guid>
        <pubDate>Sat, 20 Sep 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Python functions&lt;/p&gt;

&lt;p&gt;There are many python&amp;#39;s function types. Such as if-else, if-elif-else, for in, while, &lt;/p&gt;

&lt;p&gt;lambda etc. &lt;/p&gt;

&lt;p&gt;learning&lt;em&gt;python&lt;/em&gt;func.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/19/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

&amp;quot;&amp;quot;&amp;quot;
if else structure
&amp;quot;&amp;quot;&amp;quot;
import statsout


def my_abs(x):
    if x &amp;gt;= 0:
        return x
    else:
        return -x

&amp;quot;&amp;quot;&amp;quot;
while structure
&amp;quot;&amp;quot;&amp;quot;
def my_power(x,y):
    tmp = 1
    while y &amp;gt; 0:
        y = y - 1
        tmp = tmp * x
    return tmp

def my_power_5(x, y = 5):
    tmp = 1
    while y &amp;gt; 0:
        y = y - 1
        tmp = tmp * x
    return tmp

&amp;quot;&amp;quot;&amp;quot;
For loop structure
&amp;quot;&amp;quot;&amp;quot;
def my_for_in():
    temp = 0
    for i in range(2,10):
        for j in range(1,i):
            temp = temp + i + j
    return temp


&amp;quot;&amp;quot;&amp;quot;
Internal function
range(), len()
&amp;quot;&amp;quot;&amp;quot;

def my_range_len():
    a = [&amp;#39;Mary&amp;#39;, &amp;#39;had&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;little&amp;#39;, &amp;#39;lamb&amp;#39;]
    for i in range(len(a)):
        print i, a[i]


&amp;quot;&amp;quot;&amp;quot;
function doc
&amp;quot;&amp;quot;&amp;quot;
def func_doc():
    &amp;quot;&amp;quot;&amp;quot;
    test the function doc!
    print test_func_doc.__doc__
    &amp;quot;&amp;quot;&amp;quot;
    pass

&amp;quot;&amp;quot;&amp;quot;
lambda
example: lambda var: logc 
&amp;quot;&amp;quot;&amp;quot;
def lambda_func():
    print &amp;quot;Show how lamanda work:&amp;quot;, (lambda x:x*3)(4)

&amp;#39;&amp;#39;&amp;#39;
fib function
&amp;#39;&amp;#39;&amp;#39;
def fib(n):
    a, b = 0, 1
    while a &amp;lt; n:
        print a
        a, b = b, a+b

def fib_list(n):
    a, b = 0, 1
    result = []
    while a &amp;lt; n:
        result.append(a)
        a, b = b, a+b
    &amp;#39;&amp;#39;&amp;#39;
    return a list object
    &amp;#39;&amp;#39;&amp;#39;
    return result 

&amp;#39;&amp;#39;&amp;#39;
input argument contain list and xingcan
&amp;#39;&amp;#39;&amp;#39;
def f(a, L=[]):
    L.append(a)
    return L


#*argument means list
#**keywords means dict
def cheeseshop(kind, *arguments, **keywords):
    print &amp;quot;-- Do you have any&amp;quot;, kind, &amp;quot;?&amp;quot;
    print &amp;quot;-- I&amp;#39;m sorry, we&amp;#39;re all out of&amp;quot;, kind
    #list, for loop to catch the data
    for arg in arguments:
        print arg
    print &amp;quot;-&amp;quot; * 40

    #dict, for loop to catch the data
    keys = sorted(keywords.keys())
    for kw in keys:
        print kw, &amp;quot;:&amp;quot;, keywords[kw]

#getattri
def test_getattri(self):
    li = [&amp;#39;test1&amp;#39;,&amp;#39;test2&amp;#39;]
    getattr(li, &amp;quot;append&amp;quot;)(&amp;quot;test3&amp;quot;)
    print li

def output(data, format=&amp;quot;text&amp;quot;):
    output_function = getattr(statsout, &amp;quot;output_%s&amp;quot; % format, statsout.statsout_text)
    return output_function(data)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;testing_func.py&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

__author__ = &amp;quot;Huang Moyue&amp;quot;
__version__ = &amp;quot;0.01&amp;quot;
__date__ = &amp;quot;09/19/2014&amp;quot;
__copyright__ = &amp;quot;Copyright 2014 Huang Moyue&amp;quot;

import unittest
from unittest import TestCase

from learnpy.learning_func import my_abs
import learnpy.learning_func
from learnpy.learning_func import lambda_func
from learnpy.learning_func import cheeseshop

class Test_learn_func(TestCase):

    def test_abs(self):
        self.assertEqual(5,my_abs(-5))

    def test_power(self):
        self.assertEqual(100, learnpy.learning_func.my_power(10,2))
        self.assertEqual(32,  learnpy.learning_func.my_power_5(2))

    def test_for_in(self):
        self.assertEqual(360,  learnpy.learning_func.my_for_in())

    def test_range_len(self):
        learnpy.learning_func.my_range_len()

    def test_func_doc(self):
        print learnpy.learning_func.func_doc().__doc__

    def test_lambda(self):
        lambda_func()

    def test_cheeseshop(self):
        cheeseshop(&amp;#39;Limburger&amp;#39;, &amp;#39;It\&amp;#39; very runny, sir&amp;#39;,
                   &amp;quot;It&amp;#39;s really very, VERY runny, sir.&amp;quot;,            
                   shopkeeper=&amp;#39;Michael Palin&amp;#39;,
                   client=&amp;quot;John Cleese&amp;quot;,
                   sketch=&amp;quot;Cheese Shop Sketch&amp;quot;)


if __name__ == &amp;#39;__main__&amp;#39;:
    unittest.main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      </item>
    
  </channel>
</rss>